<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contest Admin - $NUTS Sports Pick'em</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="src/assets/images/nuts-logo.jpg">
    
    <!-- Styles -->
    <link rel="stylesheet" href="src/css/styles.css">
    <link rel="stylesheet" href="src/css/enhanced-contest.css">
    
    <style>
        .admin-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        
        .entries-table {
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
        }
        
        .entries-table table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .entries-table th {
            background: #2a2a2a;
            padding: 15px;
            text-align: left;
            color: #ffa500;
            font-weight: 600;
            border-bottom: 2px solid #444;
        }
        
        .entries-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
        }
        
        .entries-table tr:hover {
            background: #252525;
        }
        
        .picks-preview {
            font-size: 0.85em;
            color: #888;
        }
        
        .score-badge {
            background: #4CAF50;
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .date-selector {
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .refresh-btn {
            background: #4CAF50;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .refresh-btn:hover {
            background: #45a049;
        }
        
        .contest-tab {
            background: #2a2a2a;
            border: 2px solid #444;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .contest-tab:hover {
            border-color: #ffa500;
            background: #333;
        }
        
        .contest-tab.active-tab {
            background: #ffa500;
            color: #000;
            border-color: #ffa500;
        }
        
        .contest-controls {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Password Protection Modal -->
    <div id="password-modal" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    ">
        <div style="
            background: #1a1a1a;
            border: 2px solid #ff6b00;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        ">
            <img src="src/assets/images/nuts-logo.jpg" alt="$NUTS Logo" style="width: 60px; height: 60px; border-radius: 50%; margin-bottom: 20px;">
            <h2 style="color: #ff6b00; margin-bottom: 10px;">Admin Access Required</h2>
            <p style="color: #ccc; margin-bottom: 20px;">Please enter the admin password to continue</p>
            
            <input type="password" id="admin-password" placeholder="Enter password" style="
                background: #2a2a2a;
                border: 1px solid #444;
                color: white;
                padding: 12px 15px;
                border-radius: 8px;
                width: 100%;
                margin-bottom: 15px;
                font-size: 16px;
            " onkeypress="if(event.key === 'Enter') checkPassword()">
            
            <button onclick="checkPassword()" style="
                background: #ff6b00;
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                width: 100%;
            ">Enter Admin Area</button>
            
            <p id="password-error" style="color: #ff4444; margin-top: 15px; display: none;">
                Incorrect password. Please try again.
            </p>
        </div>
    </div>

    <script>
        // Check if already authenticated
        const isAuthenticated = sessionStorage.getItem('adminAuthenticated') === 'true';
        if (isAuthenticated) {
            document.getElementById('password-modal').style.display = 'none';
        }

        function checkPassword() {
            const password = document.getElementById('admin-password').value;
            const correctPassword = 'NutS420!!';
            
            if (password === correctPassword) {
                // Store authentication in session
                sessionStorage.setItem('adminAuthenticated', 'true');
                document.getElementById('password-modal').style.display = 'none';
            } else {
                // Show error
                document.getElementById('password-error').style.display = 'block';
                document.getElementById('admin-password').value = '';
                
                // Hide error after 3 seconds
                setTimeout(() => {
                    document.getElementById('password-error').style.display = 'none';
                }, 3000);
            }
        }

        // Focus on password input
        window.addEventListener('load', () => {
            if (!isAuthenticated) {
                document.getElementById('admin-password').focus();
            }
        });
    </script>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <img src="src/assets/images/nuts-logo.jpg" alt="$NUTS Logo" class="logo" style="width: 40px; height: 40px; border-radius: 50%;">
                <span class="brand-text">$NUTS Admin</span>
            </div>
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="mlb-contest.html" class="nav-link">MLB Contest</a>
                <a href="nfl-contest.html" class="nav-link">NFL Contest</a>
                <a href="college-football-contest.html" class="nav-link">CFB Contest</a>
                <a href="admin-contest.html" class="nav-link active">Contest Admin</a>
            </div>
        </div>
    </nav>

    <main class="admin-container">
        <h1 style="color: #ffa500; margin-bottom: 30px;">Contest Administration</h1>
        
        <!-- Contest Type Tabs -->
        <div style="margin-bottom: 30px;">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button onclick="switchContestType('mlb')" id="mlb-tab" class="contest-tab active-tab">
                    ‚öæ MLB Contest
                </button>
                <button onclick="switchContestType('nfl')" id="nfl-tab" class="contest-tab">
                    üèà NFL Weekly Contest
                </button>
                <button onclick="switchContestType('cfb')" id="cfb-tab" class="contest-tab">
                    üèà CFB Weekly Contest
                </button>
            </div>
        </div>
        
        <!-- MLB Contest Controls -->
        <div id="mlb-controls" class="contest-controls">
            <div style="margin-bottom: 30px;">
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                    <label style="color: #ffa500; font-weight: bold;">Contest Date:</label>
                    <input type="date" id="contest-date" class="date-selector">
                    <button onclick="loadContestData()" class="refresh-btn" style="background: #4CAF50;">üìã Load Data</button>
                </div>
                
                <!-- Main Action Buttons -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px; padding: 15px; background: #2a2a2a; border-radius: 8px;">
                    <button onclick="calculateAndUpdateScores()" class="refresh-btn" style="background: #FFD700; color: #000; flex: 1;">
                        üìä Update Scores and Table
                    </button>
                    <button onclick="manualScoreDebugger()" class="refresh-btn" style="background: #FF4444; color: #fff; flex: 1;">
                        üîß Manual Score Debugger
                    </button>
                    <button onclick="forceRecalculateAllScores()" class="refresh-btn" style="background: #4CAF50; color: #fff; flex: 1;">
                        üöÄ Force Recalculate All
                    </button>
                </div>
                
                <!-- Verification Button -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 8px; border: 1px solid #444;">
                    <button onclick="verifyDatabaseScores()" class="refresh-btn" style="background: #2196F3; color: #fff; flex: 1;">
                        üîç Verify Database Scores
                    </button>
                    <button onclick="verifyManualScoresPersistence()" class="refresh-btn" style="background: #9C27B0; color: #fff; flex: 1;">
                        üîç Verify Manual Score Persistence
                    </button>
                    <span style="color: #888; font-size: 0.9em; line-height: 2.2; flex: 2;">
                        Verify that all scores are properly saved to the database for contest resolution
                    </span>
                </div>
            </div>
            
            <!-- Game Progress Display -->
            <div id="game-progress" style="background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 15px; margin-bottom: 20px; display: none;">
                <h3 style="color: #ffa500; margin: 0 0 10px 0;">üìä Live Game Status</h3>
                <div id="game-progress-content">
                    <p style="color: #888; margin: 0;">Click "Update Game Results" to see live game status</p>
                </div>
            </div>
        </div>
        
        <!-- NFL Contest Controls -->
        <div id="nfl-controls" class="contest-controls" style="display: none;">
            <div style="margin-bottom: 30px;">
                <label style="margin-right: 10px;">NFL Week:</label>
                <select id="nfl-week-selector" class="date-selector" style="width: auto; margin-right: 10px;">
                    <option value="1">Week 1</option>
                    <option value="2">Week 2</option>
                    <option value="3">Week 3</option>
                    <option value="4">Week 4</option>
                    <option value="5">Week 5</option>
                    <option value="6">Week 6</option>
                    <option value="7">Week 7</option>
                    <option value="8">Week 8</option>
                    <option value="9">Week 9</option>
                    <option value="10">Week 10</option>
                    <option value="11">Week 11</option>
                    <option value="12">Week 12</option>
                    <option value="13">Week 13</option>
                    <option value="14">Week 14</option>
                    <option value="15">Week 15</option>
                    <option value="16">Week 16</option>
                    <option value="17">Week 17</option>
                    <option value="18">Week 18</option>
                </select>
                <button onclick="loadNFLContestData()" class="refresh-btn">Load Data</button>
                <button onclick="debugNFLStorage()" class="refresh-btn" style="background: #2196F3; margin-left: 10px;">Debug Storage</button>
                <button onclick="clearNFLWeekData()" class="refresh-btn" style="background: #ff4444; margin-left: 10px;">Clear Week Data</button>
                <button onclick="clearAllNFLData()" class="refresh-btn" style="background: #ff6600; margin-left: 5px;">Clear All NFL</button>
            </div>
        </div>
        
        <!-- CFB Contest Controls -->
        <div id="cfb-controls" class="contest-controls" style="display: none;">
            <div style="margin-bottom: 30px;">
                <label style="margin-right: 10px;">CFB Week:</label>
                <select id="cfb-week-selector" class="date-selector" style="width: auto; margin-right: 10px;">
                    <option value="1">Week 1</option>
                    <option value="2">Week 2</option>
                    <option value="3">Week 3</option>
                    <option value="4">Week 4</option>
                    <option value="5">Week 5</option>
                    <option value="6">Week 6</option>
                    <option value="7">Week 7</option>
                    <option value="8">Week 8</option>
                    <option value="9">Week 9</option>
                    <option value="10">Week 10</option>
                    <option value="11">Week 11</option>
                    <option value="12">Week 12</option>
                    <option value="13">Week 13</option>
                    <option value="14">Week 14</option>
                    <option value="15">Week 15</option>
                </select>
                <button onclick="loadCFBContestData()" class="refresh-btn">Load Data</button>
                <button onclick="debugCFBStorage()" class="refresh-btn" style="background: #2196F3; margin-left: 10px;">Debug Storage</button>
                <button onclick="clearCFBWeekData()" class="refresh-btn" style="background: #ff4444; margin-left: 10px;">Clear Week Data</button>
                <button onclick="clearAllCFBData()" class="refresh-btn" style="background: #ff6600; margin-left: 5px;">Clear All CFB</button>
            </div>
        </div>
        
        <!-- Statistics -->
        <div class="stats-grid" id="stats-grid">
            <div class="stat-card">
                <h3>Total Entries</h3>
                <div class="stat-value" id="total-entries">0</div>
            </div>
            <div class="stat-card">
                <h3>Prize Pool</h3>
                <div class="stat-value" id="prize-pool">0 NUTS</div>
            </div>
            <div class="stat-card">
                <h3>Contest Status</h3>
                <div class="stat-value" id="contest-status">Pending</div>
            </div>
            <div class="stat-card">
                <h3>Average Score</h3>
                <div class="stat-value" id="avg-score">0</div>
            </div>
        </div>
        
        <!-- Auto-Update Status -->
        <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
            <span style="color: #4CAF50;">üîÑ Auto-Update:</span>
            <span id="auto-update-status" style="color: #ccc;">Checking for game results every 10 minutes...</span>
            <span id="last-update" style="color: #888; margin-left: 10px;"></span>
        </div>
        
        <!-- Contest Winners Display -->
        <div id="winners-display" style="background: #1a1a1a; border: 2px solid #4CAF50; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: none;">
            <h2 style="color: #4CAF50; text-align: center; margin: 0 0 20px 0;">üèÜ Contest Winners üèÜ</h2>
            <div id="winners-content">
                <!-- Winner details and action buttons will be populated here dynamically -->
            </div>
        </div>
        
        <!-- Entries Table -->
        <div class="entries-table">
            <h2 style="padding: 20px; color: #ffa500;" id="entries-table-title">MLB Contest Entries</h2>
            <table>
                <thead>
                    <tr>
                        <th>Entry ID</th>
                        <th>User</th>
                        <th>X Handle</th>
                        <th>Wallet</th>
                        <th>Picks</th>
                        <th id="tiebreaker-header">Tiebreaker</th>
                        <th>Score</th>
                        <th>Prize</th>
                        <th>Status</th>
                        <th>Time</th>
                    </tr>
                </thead>
                <tbody id="entries-tbody">
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            Select a date and click Load Data
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- Actions -->
        <div style="margin-top: 30px; text-align: center;">
            <button onclick="calculateWinners()" class="btn btn-primary" style="margin-right: 10px;">
                Calculate Winners
            </button>
            <button onclick="completeContest()" class="btn btn-primary" style="margin-right: 10px; background: #ff9900;">
                Complete Contest
            </button>
            <button onclick="exportData()" class="btn btn-secondary">
                Export to CSV
            </button>
        </div>
    </main>

    <!-- Payout Modal -->
    <div id="payout-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="background: #1a1a1a; border: 2px solid #ff6b00; border-radius: 12px; padding: 30px; margin: 50px auto; max-width: 600px; position: relative;">
            <button onclick="closePayoutModal()" style="position: absolute; top: 10px; right: 10px; background: #ff6b00; border: none; color: white; width: 30px; height: 30px; border-radius: 50%; cursor: pointer;">√ó</button>
            
            <h2 style="color: #ff6b00; margin-bottom: 20px;">Manual Payout Process</h2>
            
            <div style="background: #ff3333; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <strong>‚ö†Ô∏è IMPORTANT: All payouts must be sent manually through your Xaman wallet</strong>
            </div>
            
            <div id="payout-details" style="margin-bottom: 20px;">
                <!-- Details will be populated dynamically -->
            </div>
            
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button onclick="showManualPayment()" style="flex: 1; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    üìã Show Manual Payment Info
                </button>
                <button onclick="generatePayoutQR()" style="flex: 1; background: #ff6b00; color: white; border: none; padding: 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    üì± Generate QR Code
                </button>
            </div>
            
            <div id="payment-method-content" style="margin-top: 20px;">
                <!-- Payment method content will appear here -->
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
    <script src="config/config-browser.js"></script>
    <script src="config/environment.js"></script>
    <script src="src/js/firebase-integration.js"></script>
    <script src="src/js/firebase-xaman-integration.js"></script>
    <script src="src/js/contest-backend.js"></script>
    <script src="src/js/contest-backend-production.js"></script>
    <script src="src/js/contest-backend-enhanced.js"></script>
    <script src="src/js/enhanced-display.js"></script>
    <script src="src/js/mlb-schedule-free.js"></script>
    <script src="src/js/cfb-schedule-api.js"></script>
    <script src="src/js/contest-integration-enhanced.js"></script>
    
    <script>
        let integration;
        let backend;
        let currentEntries = [];
        let currentContestType = 'mlb'; // 'mlb', 'nfl', or 'cfb'
        let currentNFLWeek = 1;
        let currentCFBWeek = 1;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Set today's date as default in EST
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const todayString = `${year}-${month}-${day}`;
            
            document.getElementById('contest-date').value = todayString;
            console.log('üìÖ Set default date to:', todayString);
            
            // Initialize Firebase integration first
            console.log('üî• Setting up Firebase integration...');
            
            // Wait for firebaseIntegration to be available (it might be created by firebase-integration.js)
            let retries = 0;
            const maxRetries = 50;
            
            while (!window.firebaseIntegration && retries < maxRetries) {
                console.log('‚è≥ Waiting for Firebase Integration to load...');
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }
            
            // If not available, create it
            if (!window.firebaseIntegration) {
                console.log('üîß Creating Firebase Integration instance...');
                window.firebaseIntegration = new FirebaseIntegration();
            }
            
            console.log('üîÑ Starting Firebase initialization...');
            await window.firebaseIntegration.initialize();
            
            // Initialize Firebase + Xaman integration
            integration = new FirebaseXamanIntegration();
            await integration.init();
            
            // Always use production Firebase backend - NO LOCAL STORAGE
            console.log('üåê Using production Firebase backend ONLY - no local storage allowed');
            
            // Force production backend only
            if (window.ContestBackendProduction) {
                backend = new ContestBackendProduction();
                await backend.init();
                console.log('‚úÖ Production Firebase backend initialized');
                
                // Store reference for global access
                window.backend = backend;
                window.contestBackendProduction = backend;
            } else {
                console.error('‚ùå Production backend not available!');
                alert('Error: Production Firebase backend not available. Please refresh the page.');
                return;
            }
            
            // Verify we have a production Firebase backend
            if (!backend || backend.constructor.name !== 'ContestBackendProduction') {
                console.error('‚ùå Only production Firebase backend allowed!');
                alert('Error: Production Firebase backend required. Please refresh the page.');
                return;
            }
            
            // Load today's data
            loadContestData();
            
            // Set up automatic score updates every 10 minutes
            console.log('‚è∞ Setting up automatic score updates...');
            setInterval(async () => {
                const contestDate = document.getElementById('contest-date').value;
                if (contestDate && currentEntries.length > 0) {
                    console.log('üîÑ Automatic score update check...');
                    
                    // Update status
                    const statusElement = document.getElementById('auto-update-status');
                    if (statusElement) {
                        statusElement.textContent = 'Checking for updates...';
                        statusElement.style.color = '#ff9900';
                    }
                    
                    try {
                        const gameResults = await fetchRealGameResults(contestDate, false); // false = no alert
                        if (Object.keys(gameResults).length > 0) {
                            await updateEntryScores(gameResults);
                            updateStats({ totalEntries: currentEntries.length, prizePool: currentEntries.length * 50, avgScore: 0 });
                            
                            // Use enhanced display if available
                            if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                                window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                            } else {
                                updateEntriesTable(currentEntries);
                            }
                            
                            console.log('‚úÖ Automatic score update completed');
                            
                            if (statusElement) {
                                statusElement.textContent = 'Scores updated with live results!';
                                statusElement.style.color = '#4CAF50';
                            }
                        } else {
                            if (statusElement) {
                                statusElement.textContent = 'No completed games yet...';
                                statusElement.style.color = '#888';
                            }
                        }
                        
                        // Update last check time
                        const lastUpdateElement = document.getElementById('last-update');
                        if (lastUpdateElement) {
                            lastUpdateElement.textContent = `Last checked: ${new Date().toLocaleTimeString()}`;
                        }
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Automatic score update failed:', error);
                        if (statusElement) {
                            statusElement.textContent = 'Update failed - will retry...';
                            statusElement.style.color = '#ff4444';
                        }
                    }
                }
            }, 10 * 60 * 1000); // Every 10 minutes
        });
        
        async function loadContestData() {
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a date');
                return;
            }
            
            // Force production Firebase backend only
            if (!backend || backend.constructor.name !== 'ContestBackendProduction') {
                console.error('‚ùå Production Firebase backend required!');
                alert('Error: Production Firebase backend required. Please refresh the page.');
                return;
            }
            
            // Verify backend is ready and is production
            console.log('‚úÖ Using production Firebase backend:', backend.constructor.name);
            
            try {
                console.log('üîÑ Loading data for', contestDate);
                console.log('üîÑ Firebase enabled:', integration?.firebase?.initialized);
                console.log('üîÑ Production backend ready:', backend?.constructor?.name === 'ContestBackendProduction');
                
                // Get entries from production Firebase backend ONLY
                console.log('ÔøΩ Using production Firebase backend to get entries...');
                
                // Use production Firebase backend only
                console.log('üîß Production Firebase backend confirmed:', backend.constructor.name);
                
                // Try with sport filter first, then without if no results (for backward compatibility)
                currentEntries = await backend.getContestEntries(contestDate, currentContestType);
                
                // If no results with sport filter, try without filter for MLB (backward compatibility)
                if (currentEntries.length === 0 && currentContestType === 'mlb') {
                    console.log('üîÑ No entries found with sport filter, trying without filter for backward compatibility...');
                    currentEntries = await backend.getContestEntries(contestDate);
                }
                
                console.log('üìä Final loaded entries:', currentEntries.length, currentEntries.length > 0 ? currentEntries[0] : 'none');
                
                // Debug: Log entry structure for first entry
                if (currentEntries.length > 0) {
                    console.log('üîç First entry structure:', {
                        id: currentEntries[0].id,
                        userName: currentEntries[0].userName,
                        score: currentEntries[0].score,
                        tiebreakerRuns: currentEntries[0].tiebreakerRuns,
                        picks: currentEntries[0].picks,
                        totalPicksCount: currentEntries[0].picks ? Object.keys(currentEntries[0].picks).length : 0,
                        sampleGameIds: currentEntries[0].picks ? Object.keys(currentEntries[0].picks).slice(0, 3) : []
                    });
                    
                    // Show tiebreaker info for all entries
                    console.log('üèÉ Tiebreaker values for all entries:');
                    currentEntries.forEach((entry, index) => {
                        console.log(`  ${index + 1}. ${entry.userName}: ${entry.tiebreakerRuns || 'No tiebreaker'} runs`);
                    });
                }
                
                // Get stats - use backend if available, otherwise integration
                let stats;
                if (backend.getContestStats) {
                    stats = await backend.getContestStats(currentContestType, contestDate);
                } else {
                    stats = await integration.getContestStats(contestDate);
                }
                
                // Update UI
                updateStats(stats);
                
                // Enrich entries with team details if enhanced backend is available
                let enrichedEntries = currentEntries;
                if (window.contestBackendEnhanced) {
                    try {
                        console.log('üöÄ Enriching entries with team details...');
                        enrichedEntries = await Promise.all(currentEntries.map(async (entry) => {
                            if (entry.picks && !entry.gamesDetailed) {
                                try {
                                    const enrichedGames = await window.contestBackendEnhanced.enrichPicksWithGameDetails(entry.picks, contestDate);
                                    return {
                                        ...entry,
                                        gamesDetailed: enrichedGames
                                    };
                                } catch (enrichError) {
                                    console.warn('‚ö†Ô∏è Failed to enrich entry:', entry.id, enrichError);
                                    return entry;
                                }
                            }
                            return entry;
                        }));
                        console.log('‚úÖ Entries enriched with team details');
                        
                        // Update the current entries with enriched data
                        currentEntries = enrichedEntries;
                    } catch (enrichError) {
                        console.warn('‚ö†Ô∏è Failed to enrich entries, using original data:', enrichError);
                        enrichedEntries = currentEntries;
                    }
                }
                
                // Merge with enhanced results if available from previous score calculations
                if (window.enhancedEntryResults && window.enhancedEntryResults[contestDate]) {
                    console.log('üîÑ Merging with enhanced entry results from session...');
                    enrichedEntries = enrichedEntries.map(entry => {
                        const enhancedResult = window.enhancedEntryResults[contestDate][entry.id];
                        if (enhancedResult) {
                            console.log(`üìä Merging enhanced results for ${entry.userName}: score ${enhancedResult.score}, ${enhancedResult.gamesDetailed?.length || 0} detailed games`);
                            return {
                                ...entry,
                                ...enhancedResult
                            };
                        }
                        return entry;
                    });
                    currentEntries = enrichedEntries;
                    console.log('‚úÖ Enhanced results merged successfully');
                }
                
                // Use enhanced display if available, otherwise fall back to standard
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    console.log('üåü Using enhanced admin display function');
                    window.enhancedDisplay.displayAdminEntries(enrichedEntries, contestDate);
                } else {
                    console.log('üìä Using standard admin display function');
                    updateEntriesTable(enrichedEntries);
                }
                
            } catch (error) {
                console.error('Failed to load data:', error);
                alert('Failed to load contest data: ' + error.message);
            }
        }
        
        // Contest type switching functions
        function switchContestType(type) {
            currentContestType = type;
            
            // Update tab appearance
            document.querySelectorAll('.contest-tab').forEach(tab => {
                tab.classList.remove('active-tab');
            });
            document.getElementById(`${type}-tab`).classList.add('active-tab');
            
            // Show/hide controls
            document.getElementById('mlb-controls').style.display = type === 'mlb' ? 'block' : 'none';
            document.getElementById('nfl-controls').style.display = type === 'nfl' ? 'block' : 'none';
            document.getElementById('cfb-controls').style.display = type === 'cfb' ? 'block' : 'none';
            
            // Update table title and headers
            let tableTitle = '';
            let tiebreakerHeader = '';
            
            if (type === 'mlb') {
                tableTitle = 'MLB Contest Entries';
                tiebreakerHeader = 'Tiebreaker';
            } else if (type === 'nfl') {
                tableTitle = 'NFL Contest Entries';
                tiebreakerHeader = 'Tiebreaker Points';
            } else if (type === 'cfb') {
                tableTitle = 'CFB Contest Entries';
                tiebreakerHeader = 'Tiebreaker Points';
            }
            
            document.getElementById('entries-table-title').textContent = tableTitle;
            document.getElementById('tiebreaker-header').textContent = tiebreakerHeader;
            
            // Update stats grid headers for context
            const statCards = document.querySelectorAll('.stat-card h3');
            if (type === 'nfl') {
                statCards[0].textContent = 'Week Entries';
                statCards[1].textContent = 'Week Pool';
                statCards[2].textContent = 'Week Status';
                statCards[3].textContent = 'Avg Score';
            } else if (type === 'cfb') {
                statCards[0].textContent = 'Week Entries';
                statCards[1].textContent = 'Week Pool';
                statCards[2].textContent = 'Week Status';
                statCards[3].textContent = 'Avg Score';
            } else {
                statCards[0].textContent = 'Total Entries';
                statCards[1].textContent = 'Prize Pool';
                statCards[2].textContent = 'Contest Status';
                statCards[3].textContent = 'Average Score';
            }
            
            // Clear current data
            currentEntries = [];
            document.getElementById('entries-tbody').innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; color: #888;">
                        ${type === 'mlb' ? 'Select a date and click Load Data' : 'Select a week and click Load Data'}
                    </td>
                </tr>
            `;
            
            // Reset stats
            updateStats({ totalEntries: 0, prizePool: 0, avgScore: 0 });
        }
        
        // NFL-specific functions
        async function loadNFLContestData() {
            const weekSelector = document.getElementById('nfl-week-selector');
            const selectedWeek = parseInt(weekSelector.value);
            currentNFLWeek = selectedWeek;
            
            try {
                console.log('üèà Loading NFL data for week', selectedWeek);
                
                // Get NFL entries using production Firebase backend ONLY
                console.log('üìä Using production Firebase backend for NFL entries...', backend.constructor.name);
                
                // Calculate the week date for the backend call
                const seasonStart = new Date(2025, 8, 7); // September 7, 2025
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((selectedWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                // Get NFL entries from Firebase backend only
                let nflEntries = [];
                try {
                    nflEntries = await backend.getContestEntries(weekDateString, 'nfl', selectedWeek);
                    console.log('üìä Got NFL entries from Firebase backend:', nflEntries.length);
                } catch (error) {
                    console.error('Failed to get NFL entries from Firebase backend:', error);
                    nflEntries = [];
                }
                
                currentEntries = nflEntries;
                console.log('üìä Final NFL entries loaded:', currentEntries.length);
                
                // Calculate stats
                let stats;
                if (backend.getContestStats) {
                    try {
                        stats = await backend.getContestStats('nfl', weekDateString, selectedWeek);
                    } catch (error) {
                        console.warn('Failed to get stats from backend, calculating locally:', error);
                        stats = calculateNFLStats(currentEntries);
                    }
                } else {
                    stats = calculateNFLStats(currentEntries);
                }
                
                // Update UI
                updateStats(stats);
                updateNFLEntriesTable(currentEntries);
                
            } catch (error) {
                console.error('Failed to load NFL data:', error);
                alert('Failed to load NFL contest data: ' + error.message);
            }
        }
        
        function calculateNFLStats(entries) {
            const totalEntries = entries.length;
            const prizePool = totalEntries * 50; // 50 NUTS per entry
            const avgScore = entries.length > 0 ? 
                entries.reduce((sum, entry) => sum + (entry.score || 0), 0) / entries.length : 0;
            
            return { totalEntries, prizePool, avgScore };
        }
        
        function updateNFLEntriesTable(entries) {
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for NFL Week ${currentNFLWeek}
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = entries.map(entry => `
                <tr>
                    <td style="font-family: monospace; font-size: 0.85em;">
                        ${entry.id ? entry.id.substring(0, 12) + '...' : 'NFL_' + Date.now()}
                    </td>
                    <td>${entry.userName || entry.name || 'Anonymous'}</td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview">
                        ${Object.keys(entry.picks || {}).length} picks
                    </td>
                    <td>${entry.tiebreakerPoints || 0} points</td>
                    <td>
                        ${entry.score !== undefined ? 
                            `<span class="score-badge">${entry.score}</span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td>${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${entry.timestamp ? new Date(entry.timestamp).toLocaleString() : 'N/A'}
                    </td>
                </tr>
            `).join('');
        }
        
        // NFL data clearing functions
        function clearNFLWeekData() {
            if (!confirm(`Clear all data for NFL Week ${currentNFLWeek}?`)) return;
            
            const keysToRemove = [
                `nfl_contest_entries_week_${currentNFLWeek}`,
                `nfl_entries_week_${currentNFLWeek}`,
                `contest_entries_nfl_week_${currentNFLWeek}`
            ];
            
            keysToRemove.forEach(key => localStorage.removeItem(key));
            alert(`Cleared NFL Week ${currentNFLWeek} data`);
            loadNFLContestData();
        }
        
        function clearAllNFLData() {
            if (!confirm('Clear ALL NFL contest data? This cannot be undone!')) return;
            
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (key && key.includes('nfl')) {
                    localStorage.removeItem(key);
                }
            }
            
            alert('Cleared all NFL contest data');
            loadNFLContestData();
        }
        
        function debugNFLStorage() {
            console.log('üîç Debug: Production Firebase Backend Status');
            console.log('üîß Backend type:', backend?.constructor?.name || 'Not available');
            console.log('üîß Backend ready:', backend ? 'Yes' : 'No');
            
            // Test backend connection
            if (backend && typeof backend.getContestStats === 'function') {
                console.log('‚úÖ Backend connection test: Functional');
                
                // Try to get current NFL week stats
                const seasonStart = new Date(2025, 8, 7); // September 7, 2025
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((currentNFLWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                backend.getContestStats('nfl', weekDateString, currentNFLWeek)
                    .then(stats => {
                        console.log(`üìä NFL Week ${currentNFLWeek} stats from Firebase:`, stats);
                    })
                    .catch(error => {
                        console.error('‚ùå Failed to get NFL stats from Firebase:', error);
                    });
            } else {
                console.log('‚ùå Backend connection test: Failed');
            }
            
            alert('Production Firebase backend debug complete. Check console for details.');
        }
        
        // CFB-specific functions
        async function loadCFBContestData() {
            const weekSelector = document.getElementById('cfb-week-selector');
            const selectedWeek = parseInt(weekSelector.value);
            currentCFBWeek = selectedWeek;
            
            try {
                console.log('üèà Loading CFB data for week', selectedWeek);
                
                // Get CFB entries using production Firebase backend ONLY
                console.log('üìä Using production Firebase backend for CFB entries...', backend.constructor.name);
                
                // Calculate the week date for the backend call
                const seasonStart = new Date(2025, 7, 1); // August 1, 2025 for CFB
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((selectedWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                // Get CFB entries from Firebase backend only
                let cfbEntries = [];
                try {
                    cfbEntries = await backend.getContestEntries(weekDateString, 'cfb', selectedWeek);
                    console.log('üìä Got CFB entries from Firebase backend:', cfbEntries.length);
                } catch (error) {
                    console.error('Failed to get CFB entries from Firebase backend:', error);
                    cfbEntries = [];
                }
                
                currentEntries = cfbEntries;
                console.log('üìä Final CFB entries loaded:', currentEntries.length);
                
                // Calculate stats
                let stats;
                if (backend.getContestStats) {
                    try {
                        stats = await backend.getContestStats('cfb', weekDateString, selectedWeek);
                    } catch (error) {
                        console.warn('Failed to get stats from backend, calculating locally:', error);
                        stats = calculateCFBStats(currentEntries);
                    }
                } else {
                    stats = calculateCFBStats(currentEntries);
                }
                
                // Update UI
                updateStats(stats);
                updateCFBEntriesTable(currentEntries);
                
            } catch (error) {
                console.error('Failed to load CFB data:', error);
                alert('Failed to load CFB contest data: ' + error.message);
            }
        }
        
        function calculateCFBStats(entries) {
            const totalEntries = entries.length;
            const prizePool = totalEntries * 1000; // 1000 NUTS per CFB entry
            const avgScore = entries.length > 0 ? 
                entries.reduce((sum, entry) => sum + (entry.score || 0), 0) / entries.length : 0;
            
            return {
                totalEntries,
                prizePool,
                avgScore: avgScore.toFixed(1),
                status: totalEntries >= 2 ? 'Active' : `Needs ${2 - totalEntries} more`
            };
        }
        
        function updateCFBEntriesTable(entries) {
            const tbody = document.getElementById('entries-tbody');
            const tableTitle = document.getElementById('entries-table-title');
            tableTitle.textContent = `CFB Week ${currentCFBWeek} Contest Entries`;
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No CFB entries for Week ${currentCFBWeek}
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort entries by score (descending) for leaderboard effect
            const sortedEntries = [...entries].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            tbody.innerHTML = sortedEntries.map((entry, index) => {
                const picksCount = entry.picks ? Object.keys(entry.picks).length : 0;
                const rank = index + 1;
                const userName = entry.userName || entry.userId || 'Anonymous';
                const transactionId = entry.transactionId || entry.paymentTxHash || 'N/A';
                
                return `
                    <tr style="background: ${rank === 1 ? 'rgba(255, 215, 0, 0.1)' : rank <= 3 ? 'rgba(192, 192, 192, 0.1)' : 'transparent'};">
                        <td>${rank}</td>
                        <td>${userName}</td>
                        <td>${picksCount}/20</td>
                        <td>${entry.score || 0}</td>
                        <td>1000 NUTS</td>
                        <td style="max-width: 100px; overflow: hidden; text-overflow: ellipsis;">
                            ${transactionId.length > 10 ? transactionId.substring(0, 10) + '...' : transactionId}
                        </td>
                        <td>${entry.tiebreaker || 'N/A'}</td>
                        <td>${entry.timestamp ? new Date(entry.timestamp).toLocaleString() : 'N/A'}</td>
                        <td>
                            <button onclick="viewCFBPicks('${entry.id || entry.entryId}')" class="view-btn">View Picks</button>
                        </td>
                        <td>CFB Week ${currentCFBWeek}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function viewCFBPicks(entryId) {
            const entry = currentEntries.find(e => e.id === entryId || e.entryId === entryId);
            if (!entry) {
                alert('Entry not found');
                return;
            }
            
            const picks = entry.picks || {};
            const picksText = Object.entries(picks).map(([gameId, teamId]) => {
                return `Game ${gameId}: Team ${teamId}`;
            }).join('\n');
            
            alert(`CFB Picks for ${entry.userName || 'Anonymous'}:\n\n${picksText}`);
        }
        
        function clearCFBWeekData() {
            if (!confirm(`Clear CFB Week ${currentCFBWeek} data? This cannot be undone!`)) return;
            
            // Clear any local storage data (if exists)
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.includes(`cfb_week_${currentCFBWeek}`)) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => localStorage.removeItem(key));
            
            alert(`Cleared CFB Week ${currentCFBWeek} data`);
            loadCFBContestData();
        }
        
        function clearAllCFBData() {
            if (!confirm('Clear ALL CFB contest data? This cannot be undone!')) return;
            
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (key && key.includes('cfb')) {
                    localStorage.removeItem(key);
                }
            }
            
            alert('Cleared all CFB contest data');
            loadCFBContestData();
        }
        
        function debugCFBStorage() {
            console.log('üîç Debug: CFB Production Firebase Backend Status');
            console.log('üîß Backend type:', backend?.constructor?.name || 'Not available');
            console.log('üîß Backend ready:', backend ? 'Yes' : 'No');
            
            // Test backend connection
            if (backend && typeof backend.getContestStats === 'function') {
                console.log('‚úÖ Backend connection test: Functional');
                
                // Try to get current CFB week stats
                const seasonStart = new Date(2025, 7, 1); // August 1, 2025 for CFB
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((currentCFBWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                backend.getContestStats('cfb', weekDateString, currentCFBWeek)
                    .then(stats => {
                        console.log(`üìä CFB Week ${currentCFBWeek} stats from Firebase:`, stats);
                    })
                    .catch(error => {
                        console.error('‚ùå Failed to get CFB stats from Firebase:', error);
                    });
            } else {
                console.log('‚ùå Backend connection test: Failed');
            }
            
            alert('CFB Production Firebase backend debug complete. Check console for details.');
        }
        
        function updateStats(stats) {
            console.log('üìä Updating stats with:', stats);
            
            // Handle both direct stats object and nested stats object
            const actualStats = stats.stats || stats;
            
            document.getElementById('total-entries').textContent = actualStats.totalEntries || 0;
            document.getElementById('prize-pool').textContent = (actualStats.prizePool || 0) + ' NUTS';
            document.getElementById('contest-status').textContent = 
                (actualStats.totalEntries || 0) >= 2 ? 'Active' : 'Needs ' + (2 - (actualStats.totalEntries || 0)) + ' more';
            
            // Handle avgScore safely
            const avgScore = actualStats.avgScore || actualStats.averageScore || 0;
            document.getElementById('avg-score').textContent = Number(avgScore).toFixed(1);
        }
        
        function updateEntriesTable(entries) {
            if (currentContestType === 'nfl') {
                updateNFLEntriesTable(entries);
                return;
            }
            
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for this date
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort entries by score (descending) for leaderboard effect
            const sortedEntries = [...entries].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            // Check if scores are calculated
            const hasScores = sortedEntries.some(entry => entry.score !== undefined);
            const contestDate = document.getElementById('contest-date').value;
            const hasLocalScores = contestDate && localStorage.getItem(`scores_${contestDate}`);
            
            tbody.innerHTML = sortedEntries.map((entry, index) => {
                // Create detailed picks display
                const picksHtml = formatPicksDisplay(entry.picks || {});
                
                // Determine rank styling
                const rank = index + 1;
                const rankStyle = rank === 1 ? 'color: #FFD700; font-weight: bold;' : // Gold
                                 rank === 2 ? 'color: #C0C0C0; font-weight: bold;' : // Silver  
                                 rank === 3 ? 'color: #CD7F32; font-weight: bold;' : // Bronze
                                 'color: #888;';
                
                // Score display with indicators
                let scoreDisplay = '';
                if (entry.score !== undefined) {
                    const scoreIndicator = hasLocalScores ? 'üíæ' : 'üîÑ';
                    scoreDisplay = `<span class="score-badge" style="font-size: 1.1em; ${rank <= 3 ? 'background: ' + (rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32') + '; color: #000;' : ''}">${entry.score} ${scoreIndicator}</span>`;
                } else {
                    scoreDisplay = '<span style="color: #666;">Not calculated</span>';
                }
                
                return `
                <tr style="${rank <= 3 && hasScores ? 'background: rgba(255, 215, 0, 0.05);' : ''}">
                    <td style="font-family: monospace; font-size: 0.85em;">
                        <span style="${rankStyle}">#${rank}</span><br>
                        ${entry.id.substring(0, 8)}...
                    </td>
                    <td>
                        <strong>${entry.userName}</strong>
                        ${rank <= 3 && hasScores ? `<br><small style="${rankStyle}">${rank === 1 ? 'üëë Leader' : rank === 2 ? 'ü•à 2nd Place' : 'ü•â 3rd Place'}</small>` : ''}
                    </td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview" style="max-width: 200px;">
                        ${picksHtml}
                    </td>
                    <td style="text-align: center;">
                        <strong>${entry.tiebreakerRuns || 0}</strong> runs
                    </td>
                    <td style="text-align: center;">
                        ${scoreDisplay}
                    </td>
                    <td style="text-align: center;">${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                        ${entry.status === 'won' && entry.prizeWon > 0 ? `
                            <div style="margin-top: 5px;">
                                <button onclick="showPayoutOptions('${entry.id}')" 
                                        class="btn btn-sm" 
                                        style="background: #ff6b00; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                                    Pay Winner
                                </button>
                            </div>
                        ` : ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${new Date(entry.timestamp || entry.paymentTimestamp).toLocaleTimeString()}
                    </td>
                </tr>
            `;
            }).join('');
            
            // Add status message about scores
            if (hasScores) {
                const statusMessage = hasLocalScores ? 
                    'üíæ Scores loaded from local backup' : 
                    'üîÑ Scores calculated and saved to database';
                    
                const statusRow = `
                    <tr style="background: rgba(76, 175, 80, 0.1);">
                        <td colspan="10" style="text-align: center; padding: 10px; color: #4CAF50; font-size: 0.9em;">
                            ${statusMessage}
                        </td>
                    </tr>
                `;
                tbody.innerHTML = statusRow + tbody.innerHTML;
            }
        }
        
        // NEW FUNCTION: Format picks for display
        function formatPicksDisplay(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<span style="color: #666;">No picks</span>';
            }
            
            let html = `<div style="font-size: 0.8em;">`;
            let pickCount = 0;
            const maxDisplayPicks = 4; // Show first 4 picks, then "..."
            
            Object.entries(picks).forEach(([gameId, pick]) => {
                if (pickCount < maxDisplayPicks) {
                    // Try to get team names from the game ID or use generic names
                    const teams = getTeamNamesFromGameId(gameId);
                    const pickedTeam = pick === 'home' ? teams.home : teams.away;
                    
                    html += `
                        <div style="margin: 2px 0; padding: 2px 4px; background: #2a2a2a; border-radius: 3px; display: flex; justify-content: space-between;">
                            <span style="color: #888; font-size: 0.7em;">${teams.away} @ ${teams.home}</span>
                            <span style="color: #ffa500; font-weight: bold;">${pickedTeam}</span>
                        </div>
                    `;
                }
                pickCount++;
            });
            
            if (pickCount > maxDisplayPicks) {
                html += `<div style="color: #666; font-size: 0.7em; text-align: center; margin-top: 4px;">...and ${pickCount - maxDisplayPicks} more</div>`;
            }
            
            html += `</div>`;
            return html;
        }
        
        // Helper function to extract team names from game ID
        function getTeamNamesFromGameId(gameId) {
            // Try to extract team names from the game ID
            // Game IDs often follow patterns like "2025-08-05-NYY-BOS" or similar
            if (gameId && gameId.includes('-')) {
                const parts = gameId.split('-');
                if (parts.length >= 4) {
                    return {
                        away: parts[parts.length - 2] || 'Away',
                        home: parts[parts.length - 1] || 'Home'
                    };
                }
            }
            
            // Fallback to generic names
            return {
                away: 'Away',
                home: 'Home'
            };
        }
        
        // NEW FUNCTION: Calculate winners while preserving manually updated scores
        async function calculateWinnersPreservingManualScores() {
            const contestDate = document.getElementById('contest-date').value;
            
            try {
                console.log('üèÅ Starting contest resolution with manual score preservation...');
                
                // Get current entries with their scores
                const currentEntries = await backend.getContestEntries(contestDate, currentContestType);
                console.log('üìä Current entries before resolution:', currentEntries.length);
                
                // Store all current scores to preserve manual updates
                const preservedScores = {};
                const hasManuallyUpdatedScores = currentEntries.some(entry => entry.score > 0);
                
                currentEntries.forEach(entry => {
                    if (entry.score !== undefined && entry.score !== null) {
                        preservedScores[entry.id] = {
                            score: entry.score,
                            userName: entry.userName
                        };
                        console.log(`üíæ Preserving ${entry.userName} score: ${entry.score}`);
                    }
                });
                
                if (hasManuallyUpdatedScores) {
                    console.log('ÔøΩ Manual scores detected - will preserve during resolution');
                    
                    // Temporarily override the enhanced backend score update function
                    const originalFunction = window.contestBackendEnhanced?.updateGameResults;
                    
                    if (window.contestBackendEnhanced) {
                        window.contestBackendEnhanced.updateGameResults = function(gameResults, entries) {
                            console.log('üîí Enhanced backend override: Preserving manual scores');
                            
                            return entries.map(entry => {
                                if (preservedScores[entry.id]) {
                                    console.log(`ÔøΩ Preserving ${entry.userName}: ${preservedScores[entry.id].score}`);
                                    const preservedEntry = {
                                        ...entry,
                                        score: preservedScores[entry.id].score
                                    };
                                    
                                    // Also update the score in the database to ensure persistence
                                    backend.updateEntryScore(entry.id, preservedScores[entry.id].score)
                                        .then(result => {
                                            console.log(`‚úÖ Database score preserved for ${entry.userName}: ${preservedScores[entry.id].score}`);
                                        })
                                        .catch(error => {
                                            console.error(`‚ùå Failed to preserve database score for ${entry.userName}:`, error);
                                        });
                                    
                                    return preservedEntry;
                                }
                                return entry;
                            });
                        };
                    }
                    
                    // Call the enhanced contest resolution
                    if (window.enhancedContestIntegration?.resolveContest) {
                        await window.enhancedContestIntegration.resolveContest(contestDate);
                    }
                    
                    // Restore original function
                    if (originalFunction && window.contestBackendEnhanced) {
                        window.contestBackendEnhanced.updateGameResults = originalFunction;
                    }
                    
                    console.log('‚úÖ Contest resolved with preserved manual scores');
                    
                } else {
                    console.log('üìä No manual scores detected - proceeding with normal resolution');
                    
                    // Call the enhanced contest resolution normally
                    if (window.enhancedContestIntegration?.resolveContest) {
                        await window.enhancedContestIntegration.resolveContest(contestDate);
                    }
                }
                
                // Reload data to show final results
                await loadContestData();
                
            } catch (error) {
                console.error('‚ùå Failed to resolve contest with preserved scores:', error);
                alert('Failed to resolve contest: ' + error.message);
            }
        }

        async function calculateWinners() {
            const minimumEntries = window.config?.contest?.minimumEntries || 4;
            
            if (currentEntries.length < minimumEntries) {
                const confirmRefund = confirm(
                    `Only ${currentEntries.length} entries (minimum ${minimumEntries} required).\n\n` +
                    `The contest will be cancelled and all entry fees will be refunded.\n\n` +
                    `Process refunds?`
                );
                
                if (confirmRefund) {
                    await processRefunds();
                }
                return;
            }

            // Use the new function that preserves manual scores
            await calculateWinnersPreservingManualScores();
        }
        
        // NEW FUNCTION: Fetch real game results from MLB API
        async function fetchRealGameResults(contestDate = null, showAlert = true) {
            const dateToCheck = contestDate || document.getElementById('contest-date').value;
            
            if (!dateToCheck) {
                if (showAlert) alert('Please select a date first');
                return {};
            }
            
            try {
                console.log(`üîÑ Fetching real MLB game results for ${dateToCheck}...`);
                
                if (showAlert) {
                    document.body.style.cursor = 'wait';
                }
                
                // Initialize MLB Schedule API if not available
                if (!window.mlbSchedule) {
                    console.log('üì° Loading MLB Schedule API...');
                    const script = document.createElement('script');
                    script.src = 'src/js/mlb-schedule-free.js';
                    document.head.appendChild(script);
                    
                    // Wait for it to load
                    await new Promise(resolve => {
                        script.onload = resolve;
                        setTimeout(resolve, 2000); // fallback timeout
                    });
                }
                
                // Create date object properly to avoid timezone issues
                const dateParts = dateToCheck.split('-');
                const gameDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                
                console.log(`üóìÔ∏è Processing game results for: ${dateToCheck}`);
                console.log(`üóìÔ∏è Created date object: ${gameDate.toDateString()} (${gameDate.toISOString()})`);
                
                // Use the new getGameResults method that returns processed results
                const gameResults = await window.mlbSchedule.getGameResults(gameDate);
                
                // Always get games to show progress (regardless of completed games)
                const allGames = await window.mlbSchedule.getGamesForDate(gameDate);
                updateGameProgressDisplay(allGames);
                
                const completedGames = Object.keys(gameResults).filter(key => key !== 'lastGameRuns').length;
                
                console.log(`üìÖ Found ${completedGames} completed games for ${dateToCheck}`);
                
                if (completedGames === 0) {
                    if (showAlert) {
                        const games = await window.mlbSchedule.getGamesForDate(gameDate);
                        const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
                        const notStarted = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
                        
                        alert(`ÔøΩ Game Status Update for ${dateToCheck}:\n\n‚úÖ Completed: 0\nüîÑ In Progress: ${inProgress}\nüìÖ Not Started: ${notStarted}\n\nNo games have finished yet. Check back later!`);
                    }
                    return {};
                }
                
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    
                    alert(`üìä Game Results Updated!\n\n‚úÖ Completed Games: ${completedGames}\nüèÉ Total Runs: ${gameResults.lastGameRuns || 0}\n\nContest scores will be updated automatically.`);
                    
                    // Automatically recalculate scores for entries
                    await updateEntryScores(gameResults);
                    loadContestData(); // Refresh the display
                }
                
                return gameResults;
                
            } catch (error) {
                console.error('‚ùå Failed to fetch real game results:', error);
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    alert(`Failed to fetch game results: ${error.message}\n\nPlease check your internet connection and try again.`);
                }
                return {};
            }
        }
        
        async function processRefunds() {
            try {
                const contestDate = document.getElementById('contest-date').value;
                
                // Use the backend's refund method
                if (window.ContestBackend) {
                    const backend = new ContestBackend();
                    await backend.init();
                    
                    const result = await backend.processRefunds(contestDate);
                    
                    if (result.success) {
                        alert(
                            `‚úÖ Refunds Processed!\n\n` +
                            `Entries refunded: ${result.entriesRefunded}\n` +
                            `Total refund amount: ${result.totalRefundAmount} NUTS\n\n` +
                            `Please process the refunds manually through Xaman wallet.`
                        );
                    } else {
                        alert('Failed to process refunds: ' + result.error);
                    }
                } else {
                    alert('Contest backend not available');
                }
                
                loadContestData(); // Reload data
                
            } catch (error) {
                console.error('Failed to process refunds:', error);
                alert('Error processing refunds: ' + error.message);
            }
        }
        
        async function processAllPayouts(winners) {
            try {
                let successCount = 0;
                
                for (const winner of winners) {
                    const entry = winner.entry;
                    
                    if (!entry.walletAddress) {
                        alert(`‚ö†Ô∏è No wallet address for ${entry.userName}. Please process manually.`);
                        continue;
                    }
                    
                    // Show payout modal for each winner
                    showPayoutOptions(entry.id);
                    
                    // Wait for user to process this payout before continuing
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (!document.getElementById('payout-modal').style.display || 
                                document.getElementById('payout-modal').style.display === 'none') {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 1000);
                    });
                    
                    successCount++;
                }
                
                alert(`‚úÖ Processed ${successCount} payouts!`);
                
            } catch (error) {
                console.error('Failed to process payouts:', error);
                alert('Error processing payouts: ' + error.message);
            }
        }
        
        function exportData() {
            if (currentEntries.length === 0) {
                alert('No data to export');
                return;
            }
            
            // Create CSV
            const headers = ['Entry ID', 'User', 'X Handle', 'Wallet Address', 'Picks', 'Tiebreaker', 'Score', 'Prize', 'Status', 'Timestamp'];
            const rows = currentEntries.map(e => [
                e.id,
                e.userName,
                e.twitterHandle || '',
                e.walletAddress || '',
                Object.keys(e.picks || {}).length,
                e.tiebreakerRuns || 0,
                e.score || 0,
                e.prizeWon || 0,
                e.status || 'pending',
                new Date(e.timestamp || e.paymentTimestamp).toISOString()
            ]);
            
            const csv = [headers, ...rows].map(row => row.join(',')).join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `contest_entries_${document.getElementById('contest-date').value}.csv`;
            a.click();
        }
        
        // Payout functions
        let currentPayoutEntry = null;
        
        function showPayoutOptions(entryId) {
            const entry = currentEntries.find(e => e.id === entryId);
            if (!entry) return;
            
            currentPayoutEntry = entry;
            
            // Show modal
            document.getElementById('payout-modal').style.display = 'block';
            
            // Populate details
            document.getElementById('payout-details').innerHTML = `
                <div style="background: #2a2a2a; padding: 20px; border-radius: 8px;">
                    <h3 style="color: #4CAF50; margin-bottom: 15px;">Winner Details</h3>
                    <div style="display: grid; grid-template-columns: 150px 1fr; gap: 10px; color: #ccc;">
                        <div>Winner:</div>
                        <div style="color: white; font-weight: bold;">${entry.userName}</div>
                        
                        <div>Prize Amount:</div>
                        <div style="color: #ff6b00; font-weight: bold; font-size: 1.2em;">${entry.prizeWon} NUTS</div>
                        
                        <div>Contest Date:</div>
                        <div>${entry.contestDate}</div>
                        
                        <div>Correct Picks:</div>
                        <div>${entry.score} / ${entry.totalGames}</div>
                        
                        <div>Entry ID:</div>
                        <div style="font-family: monospace; font-size: 0.9em;">${entry.id}</div>
                    </div>
                </div>
            `;
            
            // Clear payment method content
            document.getElementById('payment-method-content').innerHTML = '';
        }
        
        function closePayoutModal() {
            document.getElementById('payout-modal').style.display = 'none';
            currentPayoutEntry = null;
        }
        
        function showManualPayment() {
            if (!currentPayoutEntry) return;
            
            // Get wallet address from entry
            const walletAddress = currentPayoutEntry.walletAddress || 'Not captured - check payment transaction';
            
            document.getElementById('payment-method-content').innerHTML = `
                <div style="background: #2a2a2a; padding: 20px; border-radius: 8px; border: 2px solid #4CAF50;">
                    <h3 style="color: #4CAF50; margin-bottom: 15px;">üìã Manual Payment Instructions</h3>
                    
                    <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <p style="color: #ff6b00; font-weight: bold; margin-bottom: 10px;">Step 1: Copy Payment Details</p>
                        <div style="color: #ccc; line-height: 1.8;">
                            <div style="margin-bottom: 10px;">
                                <strong>Recipient Wallet:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px; word-break: break-all; font-family: monospace;">
                                    ${walletAddress}
                                </div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>Amount:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px; font-size: 1.2em; color: #ff6b00;">
                                    ${currentPayoutEntry.prizeWon} NUTS
                                </div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>Memo/Note:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px;">
                                    Contest Prize - ${currentPayoutEntry.contestDate}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #1a1a1a; padding: 15px; border-radius: 8px;">
                        <p style="color: #ff6b00; font-weight: bold; margin-bottom: 10px;">Step 2: Send Payment</p>
                        <ol style="color: #ccc; line-height: 1.8; margin: 0; padding-left: 20px;">
                            <li>Open your Xaman wallet</li>
                            <li>Tap "Send"</li>
                            <li>Enter the recipient wallet address</li>
                            <li>Select NUTS from your token list</li>
                            <li>Enter the prize amount</li>
                            <li>Add the memo for reference</li>
                            <li>Review and send</li>
                        </ol>
                    </div>
                    
                    <button onclick="markPayoutComplete()" style="width: 100%; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;">
                        ‚úÖ Mark Payout as Complete
                    </button>
                </div>
            `;
        }
        
        async function generatePayoutQR() {
            if (!currentPayoutEntry) return;
            
            // Check if wallet address is available
            if (!currentPayoutEntry.walletAddress) {
                document.getElementById('payment-method-content').innerHTML = `
                    <div style="background: #ff3333; color: white; padding: 20px; border-radius: 8px; text-align: center;">
                        <p><strong>Wallet address not available!</strong></p>
                        <p style="margin-top: 10px;">The winner's wallet address was not captured during entry.</p>
                        <p>Please use the manual payment option and check the transaction history.</p>
                    </div>
                `;
                return;
            }
            
            document.getElementById('payment-method-content').innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="spinner"></div>
                    <p style="color: #ccc; margin-top: 10px;">Generating payment QR code...</p>
                </div>
            `;
            
            try {
                // Call XUMM server to create payout payload
                const response = await fetch('http://localhost:3001/create-nuts-payment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        destination: currentPayoutEntry.walletAddress || null,
                        amount: currentPayoutEntry.prizeWon.toString(),
                        memo: `Contest Prize - ${currentPayoutEntry.contestDate}`
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.payload) {
                    document.getElementById('payment-method-content').innerHTML = `
                        <div style="background: #2a2a2a; padding: 20px; border-radius: 8px; border: 2px solid #ff6b00; text-align: center;">
                            <h3 style="color: #ff6b00; margin-bottom: 15px;">üì± Scan to Send Prize</h3>
                            
                            <div style="background: white; padding: 10px; border-radius: 8px; display: inline-block; margin-bottom: 15px;">
                                <img src="${data.payload.refs.qr_png}" width="250" height="250" alt="Payment QR">
                            </div>
                            
                            <div style="color: #ccc; margin-bottom: 15px;">
                                <p><strong>Amount:</strong> ${currentPayoutEntry.prizeWon} NUTS</p>
                                <p><strong>To:</strong> ${currentPayoutEntry.userName}</p>
                            </div>
                            
                            <p style="color: #888; font-size: 0.9em;">
                                Scan with Xaman wallet to send prize payment
                            </p>
                            
                            <button onclick="markPayoutComplete()" style="width: 100%; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;">
                                ‚úÖ Payment Sent - Mark Complete
                            </button>
                        </div>
                    `;
                    
                    // Start polling for payment status
                    pollPayoutStatus(data.payload.uuid);
                } else {
                    throw new Error(data.error || 'Failed to generate QR code');
                }
                
            } catch (error) {
                console.error('Failed to generate payout QR:', error);
                document.getElementById('payment-method-content').innerHTML = `
                    <div style="background: #ff3333; color: white; padding: 20px; border-radius: 8px; text-align: center;">
                        <p>Failed to generate QR code: ${error.message}</p>
                        <p style="margin-top: 10px;">Please use manual payment option.</p>
                    </div>
                `;
            }
        }
        
        async function pollPayoutStatus(uuid) {
            // Poll for payment completion
            let attempts = 0;
            const maxAttempts = 60;
            
            const checkStatus = async () => {
                if (attempts >= maxAttempts) return;
                
                try {
                    const response = await fetch(`http://localhost:3001/payload-status/${uuid}`);
                    const data = await response.json();
                    
                    if (data.meta?.signed === true) {
                        // Payment completed
                        alert('‚úÖ Payout sent successfully!');
                        await markPayoutComplete();
                        return;
                    }
                    
                    if (!data.meta?.resolved) {
                        attempts++;
                        setTimeout(checkStatus, 5000);
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                }
            };
            
            setTimeout(checkStatus, 3000);
        }
        
        function clearSelectedDateData() {
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a date first');
                return;
            }
            
            if (confirm(`Are you sure you want to clear all contest data for ${contestDate}?`)) {
                // Clear contest entries for this date
                const keys = [
                    `contest_entries_${contestDate}`,
                    `entries_${contestDate}`
                ];
                
                keys.forEach(key => {
                    if (localStorage.getItem(key)) {
                        console.log(`üóëÔ∏è Removing ${key}`);
                        localStorage.removeItem(key);
                    }
                });
                
                alert(`Cleared contest data for ${contestDate}`);
                loadContestData(); // Reload the page data
            }
        }
        
        function clearTestData() {
            console.log('üóëÔ∏è Clearing all test data...');
            
            // Clear all localStorage keys that might contain test data
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                    key.includes('contest_entries_') || 
                    key.includes('entries_') || 
                    key.includes('test_') ||
                    key.includes('mock_') ||
                    key.includes('demo_')
                )) {
                    keysToRemove.push(key);
                }
            }
            
            console.log('üóëÔ∏è Found test data keys:', keysToRemove);
            
            keysToRemove.forEach(key => {
                console.log(`üóëÔ∏è Removing ${key}`);
                localStorage.removeItem(key);
            });
            
            alert(`Cleared ${keysToRemove.length} test data keys. Click Load Data to refresh.`);
        }
        
        async function calculateAndSaveScores() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            try {
                console.log('üßÆ Calculating and saving scores...');
                
                // Fetch the latest game results
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('No game results available for this date. Please try again later.');
                    return;
                }
                
                // Calculate and save scores
                await updateEntryScores(gameResults);
                
                alert(`‚úÖ Scores calculated and saved successfully!\n\nCheck the leaderboard for updated scores.`);
                
            } catch (error) {
                console.error('‚ùå Failed to calculate and save scores:', error);
                alert(`Failed to calculate and save scores: ${error.message}`);
            }
        }
        
        async function resolveContestEnhanced() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            try {
                console.log(`üèÜ Starting enhanced contest resolution for ${contestDate}...`);
                
                // Call the enhanced contest resolution
                if (window.resolveContest) {
                    const result = await window.resolveContest(contestDate);
                    
                    if (result && result.winners) {
                        alert(`üèÜ Contest resolved successfully!\n\nWinners: ${result.winners.length}\nTotal Prize Pool: ${result.totalPrizePool || 0} NUTS\n\nCheck the updated entries table for details.`);
                        
                        // Display the winners in the UI
                        displayContestWinners(result.winners, contestDate, result.totalPrizePool || 0);
                        
                        // Reload the data to show updated results
                        await loadContestData();
                    } else {
                        alert('Contest resolution completed, but no result details available. Please check the console for more information.');
                    }
                } else {
                    throw new Error('Enhanced contest resolution function not available');
                }
                
            } catch (error) {
                console.error('‚ùå Failed to resolve contest:', error);
                alert(`Failed to resolve contest: ${error.message}\n\nPlease check the console for more details.`);
            }
        }
        
        async function debugScoring() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            console.log('üîç DEBUG SCORING - Starting detailed analysis...');
            console.log('üìÖ Contest Date:', contestDate);
            console.log('üìä Total Entries:', currentEntries.length);
            
            // Analyze entry structure
            currentEntries.forEach((entry, index) => {
                console.log(`\nüë§ Entry ${index + 1}: ${entry.userName}`);
                console.log('  üìã Picks:', entry.picks);
                console.log('  üèÜ Current Score:', entry.score);
                console.log('  üéØ Total Picks:', entry.picks ? Object.keys(entry.picks).length : 0);
                
                if (entry.picks) {
                    Object.entries(entry.picks).forEach(([gameId, pick]) => {
                        console.log(`    üéÆ Game ${gameId}: picked ${pick}`);
                    });
                }
            });
            
            // Try to fetch game results
            console.log('\nüîÑ Fetching game results...');
            try {
                const gameResults = await fetchRealGameResults(contestDate, false);
                console.log('üéÆ Game Results:', gameResults);
                console.log('üéÆ Game Result Keys:', Object.keys(gameResults));
                
                if (Object.keys(gameResults).length === 0) {
                    console.log('‚ùå No game results returned');
                    alert('No game results found for this date. This might be because:\n\n1. Games haven\'t been played yet\n2. Games are still in progress\n3. MLB API connection issue\n\nCheck the console for more details.');
                    return;
                }
                
                // Manually calculate scores for debugging
                console.log('\nüßÆ Manual Score Calculation:');
                currentEntries.forEach((entry, index) => {
                    if (!entry.picks) return;
                    
                    let calculatedScore = 0;
                    console.log(`\nüîç Processing ${entry.userName}:`);
                    
                    Object.entries(entry.picks).forEach(([gameId, pick]) => {
                        const gameResult = gameResults[gameId];
                        console.log(`  üéØ Game ${gameId}: picked ${pick}`);
                        
                        if (gameResult) {
                            console.log(`    üìä Result: ${gameResult.winner} won (${gameResult.status})`);
                            const isCorrect = pick === gameResult.winner;
                            if (isCorrect) {
                                calculatedScore++;
                                console.log(`    ‚úÖ CORRECT!`);
                            } else {
                                console.log(`    ‚ùå Wrong`);
                            }
                        } else {
                            console.log(`    ‚ùì No result found for this game ID`);
                        }
                    });
                    
                    console.log(`  üìä Calculated Score: ${calculatedScore}`);
                });
                
                console.log('\n‚úÖ Debug analysis complete - check console for detailed breakdown');
                alert('Debug analysis complete! Check the browser console (F12) for detailed scoring breakdown.');
                
            } catch (error) {
                console.error('‚ùå Debug error:', error);
                alert('Debug failed: ' + error.message);
            }
        }
        
        async function saveScoresToDatabase() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            if (!confirm(`Calculate and save scores for ${currentEntries.length} entries to Firebase database?\n\nThis will update the leaderboard permanently.`)) {
                return;
            }
            
            try {
                console.log('üíæ Calculating and saving scores using enhanced backend...');
                
                // Get real game results first
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }
                
                // Use the enhanced backend method that calculates scores AND saves to Firebase
                console.log('üìä Using enhancedBackend.updateGameResults method...');
                if (!window.enhancedBackend) {
                    console.log('üöÄ Creating enhanced backend instance...');
                    window.enhancedBackend = new ContestBackendEnhanced();
                    await window.enhancedBackend.init();
                }
                
                const winners = await window.enhancedBackend.updateGameResults(contestDate, gameResults);
                
                // Reload the contest data to show updated scores
                await loadContestData();
                
                console.log('‚úÖ Scores calculated and saved to Firebase successfully!');
                alert(`‚úÖ Scores calculated and saved successfully!\n\nUpdated: ${currentEntries.length} entries\n\nThe contest leaderboard now shows the correct scores.`);
                
            } catch (error) {
                console.error('‚ùå Failed to calculate and save scores:', error);
                alert(`Failed to calculate and save scores: ${error.message}\n\nPlease check the console for more details.`);
            }
        }
        
        function clearAllContestData() {
            if (confirm('Are you sure you want to clear ALL contest data from localStorage? This cannot be undone!')) {
                // Clear all contest-related keys
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('contest_entries_') || key.startsWith('entries_') || key === 'contest_entries')) {
                        keys.push(key);
                    }
                }
                
                keys.forEach(key => {
                    console.log(`üóëÔ∏è Removing ${key}`);
                    localStorage.removeItem(key);
                });
                
                alert(`Cleared all contest data (${keys.length} keys removed)`);
                loadContestData(); // Reload the page data
            }
        }
        
        async function completeContest() {
            // SPECIAL DEBUG MESSAGE TO CONFIRM THIS FUNCTION IS BEING CALLED
            console.log('üö® ADMIN CONTEST COMPLETE BUTTON CLICKED - BYPASSING ALL ENHANCED INTEGRATION');
            alert('Admin Complete Contest function called - check console for confirmation');
            
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            if (!confirm(`Complete contest for ${contestDate}? This will determine winners based ONLY on current database scores with NO RECALCULATION.`)) {
                return;
            }

            try {
                console.log(`üèÅ ADMIN COMPLETE CONTEST: Processing ${contestDate} using ONLY current database scores - ZERO RECALCULATION`);
                console.log('üîí Enhanced contest integration COMPLETELY BYPASSED');
                
                // EXPLICITLY bypass any enhanced contest integration
                const originalResolveContest = window.enhancedContestIntegration?.resolveContest;
                const originalCalculateWinners = window.contestBackend?.calculateWinners;
                
                // Temporarily disable enhanced integrations to prevent accidental calls
                if (window.enhancedContestIntegration) {
                    window.enhancedContestIntegration.resolveContest = function() {
                        console.log('üö´ Enhanced contest integration call BLOCKED by admin complete contest');
                        return Promise.resolve();
                    };
                }
                
                // Get current entries from database (no score recalculation)
                const entries = await backend.getContestEntries(contestDate, currentContestType);
                
                if (entries.length === 0) {
                    alert('No entries found for this date');
                    return;
                }
                
                console.log(`üìä ADMIN COMPLETE: Found ${entries.length} entries with preserved scores`);
                console.log('üìã Current scores in database:');
                entries.forEach(entry => {
                    console.log(`   ${entry.userName}: ${entry.score} points (tiebreaker: ${entry.tiebreakerRuns || entry.tiebreaker})`);
                });
                
                // Calculate tiebreaker value (last game total runs)
                let lastGameRuns = 5; // Default fallback
                try {
                    const gameResults = await window.mlbScheduleFree.getRealGameResults(new Date(contestDate + 'T00:00:00.000Z'));
                    if (gameResults && gameResults.lastGameRuns !== undefined) {
                        lastGameRuns = gameResults.lastGameRuns;
                        console.log(`üèÉ Using actual last game runs: ${lastGameRuns}`);
                    } else {
                        console.log(`üèÉ Using fallback last game runs: ${lastGameRuns}`);
                    }
                } catch (error) {
                    console.warn('Failed to get last game runs, using fallback:', error);
                }
                
                // Calculate winners using ONLY existing database scores (NO RECALCULATION)
                const winners = calculateWinnersFromCurrentScores(entries, lastGameRuns);
                
                console.log(`üèÜ ADMIN COMPLETE: Calculated ${winners.length} winners using ONLY preserved database scores`);
                console.log('üèÜ Winners calculated without any score recalculation:');
                winners.forEach(winner => {
                    console.log(`   ${winner.place}. ${winner.entry.userName}: ${winner.entry.score} points - ${winner.prize} NUTS`);
                });
                
                // Display winners
                displayWinners(winners);
                
                // Update the entries display
                currentEntries = entries;
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    window.enhancedDisplay.displayAdminEntries(entries, contestDate);
                } else {
                    updateEntriesTable(entries);
                }
                
                // Restore original functions
                if (originalResolveContest && window.enhancedContestIntegration) {
                    window.enhancedContestIntegration.resolveContest = originalResolveContest;
                }
                
                console.log('‚úÖ ADMIN COMPLETE CONTEST: Completed successfully using ONLY preserved database scores - ZERO RECALCULATION');
                alert('Contest completed successfully using preserved database scores!');
                
            } catch (error) {
                console.error('Failed to complete contest:', error);
                alert('Error completing contest: ' + error.message);
                
                // Restore original functions in case of error
                if (originalResolveContest && window.enhancedContestIntegration) {
                    window.enhancedContestIntegration.resolveContest = originalResolveContest;
                }
            }
        }

        // Simple winner calculation that uses ONLY existing database scores
        function calculateWinnersFromCurrentScores(entries, lastGameRuns) {
            console.log('üéØ Calculating winners from current database scores ONLY');
            
            // Sort entries by score (descending), then by tiebreaker proximity
            const sortedEntries = [...entries].sort((a, b) => {
                if (a.score !== b.score) {
                    return b.score - a.score; // Higher score wins
                }
                
                // Tiebreaker: closer to lastGameRuns wins
                const aTiebreaker = a.tiebreakerRuns || a.tiebreaker || 0;
                const bTiebreaker = b.tiebreakerRuns || b.tiebreaker || 0;
                const aDiff = Math.abs(aTiebreaker - lastGameRuns);
                const bDiff = Math.abs(bTiebreaker - lastGameRuns);
                
                if (aDiff !== bDiff) {
                    return aDiff - bDiff; // Smaller difference wins
                }
                
                // If still tied, higher tiebreaker wins
                return bTiebreaker - aTiebreaker;
            });
            
            const winners = [];
            const prizeDistribution = [0.5, 0.3, 0.2]; // 50%, 30%, 20%
            const totalPrizePool = entries.length * 50; // 50 NUTS per entry
            
            for (let i = 0; i < Math.min(3, sortedEntries.length); i++) {
                const entry = sortedEntries[i];
                const prize = Math.round(totalPrizePool * prizeDistribution[i]);
                
                winners.push({
                    place: i + 1,
                    entry: entry,
                    prize: prize
                });
                
                console.log(`üèÜ Winner ${i + 1}: ${entry.userName} - ${entry.score} points - ${prize} NUTS`);
            }
            
            return winners;
        }

        // Function to display contest winners
        function displayWinners(winners) {
            const winnersDisplay = document.getElementById('winners-display');
            const winnersContent = document.getElementById('winners-content');
            
            if (!winners || winners.length === 0) {
                winnersDisplay.style.display = 'none';
                return;
            }
            
            console.log('üèÜ Displaying contest winners:', winners);
            
            // Show the winners banner
            winnersDisplay.style.display = 'block';
            
            // Generate winners HTML
            let winnersHtml = '<div style="margin-bottom: 20px;">';
            
            winners.forEach((winner, index) => {
                const place = index + 1;
                const entry = winner.entry || winner;
                const prize = winner.prize || 0;
                
                // Get wallet address from entry
                const walletAddress = entry.walletAddress || entry.playerWallet || entry.wallet || entry.xrpAddress || 'No wallet';
                
                console.log(`üîç Winner ${place} wallet check:`, {
                    walletAddress: entry.walletAddress,
                    playerWallet: entry.playerWallet,
                    wallet: entry.wallet,
                    xrpAddress: entry.xrpAddress,
                    finalWallet: walletAddress
                });
                
                const medalEmoji = place === 1 ? 'ü•á' : place === 2 ? 'ü•à' : place === 3 ? 'ü•â' : 'üèÜ';
                const placeColor = place === 1 ? '#FFD700' : place === 2 ? '#C0C0C0' : place === 3 ? '#CD7F32' : '#4CAF50';
                
                winnersHtml += `
                    <div style="background: rgba(255,255,255,0.05); border-left: 4px solid ${placeColor}; padding: 15px; margin-bottom: 10px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.2em;">${medalEmoji}</span>
                                <strong style="color: ${placeColor}; margin-left: 10px;">
                                    ${place === 1 ? '1st' : place === 2 ? '2nd' : place === 3 ? '3rd' : place + 'th'} Place
                                </strong>
                                <span style="margin-left: 15px; color: #ccc;">
                                    ${entry.userName || entry.name || 'Anonymous'}
                                </span>
                                <span style="margin-left: 10px; color: #888; font-size: 0.9em;">
                                    Score: ${entry.score || 0}
                                </span>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #4CAF50; font-weight: bold; font-size: 1.1em;">
                                    ${prize} NUTS
                                </div>
                                <div style="color: #888; font-size: 0.8em; font-family: monospace;">
                                    ${walletAddress !== 'No wallet' ? 
                                        walletAddress.substring(0, 8) + '...' + walletAddress.substring(walletAddress.length - 6) : 
                                        'No wallet provided'}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            winnersHtml += '</div>';
            
            // Add action buttons
            winnersHtml += `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="processAllPayouts(${JSON.stringify(winners).replace(/"/g, '&quot;')})" 
                            style="background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 8px; margin-right: 10px; cursor: pointer; font-weight: bold;">
                        üí∏ Process All Payouts
                    </button>
                    <button onclick="exportWinners(${JSON.stringify(winners).replace(/"/g, '&quot;')})" 
                            style="background: #2196F3; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                        üìÑ Export Winners
                    </button>
                </div>
            `;
            
            winnersContent.innerHTML = winnersHtml;
        }

        async function markPayoutComplete() {
            if (!currentPayoutEntry) return;
            
            try {
                // Update entry status
                currentPayoutEntry.payoutStatus = 'completed';
                currentPayoutEntry.payoutTimestamp = new Date().toISOString();
                
                // In production, update Firebase
                if (integration && integration.db) {
                    await integration.db.collection('contest_entries')
                        .doc(currentPayoutEntry.id)
                        .update({
                            payoutStatus: 'completed',
                            payoutTimestamp: currentPayoutEntry.payoutTimestamp
                        });
                }
                
                alert('‚úÖ Payout marked as complete!');
                closePayoutModal();
                loadContestData(); // Refresh the table
                
            } catch (error) {
                console.error('Failed to update payout status:', error);
                alert('Failed to update payout status: ' + error.message);
            }
        }
        
        // Function to update game progress display
        function updateGameProgressDisplay(games) {
            const progressDiv = document.getElementById('game-progress');
            const contentDiv = document.getElementById('game-progress-content');
            
            if (!games || games.length === 0) {
                progressDiv.style.display = 'none';
                return;
            }
            
            const completed = games.filter(g => g.status === 'Final').length;
            const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
            const scheduled = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
            const warmup = games.filter(g => g.status === 'Warmup').length;
            
            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #4CAF50; font-weight: bold;">${completed}</div>
                        <div style="color: #888; font-size: 0.9em;">‚úÖ Completed</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #ff9900; font-weight: bold;">${inProgress}</div>
                        <div style="color: #888; font-size: 0.9em;">üîÑ Live</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #2196F3; font-weight: bold;">${warmup}</div>
                        <div style="color: #888; font-size: 0.9em;">üî• Warmup</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #666; font-weight: bold;">${scheduled}</div>
                        <div style="color: #888; font-size: 0.9em;">üìÖ Scheduled</div>
                    </div>
                </div>
            `;
            
            // Show ALL games in a detailed format
            html += `<div style="border-top: 1px solid #444; padding-top: 15px;">`;
            html += `<h4 style="color: #ffa500; margin: 0 0 15px 0;">ÔøΩ All Games Today:</h4>`;
            
            // Group games by status
            const gamesByStatus = {
                'Live/In Progress': games.filter(g => g.status === 'Live' || g.status === 'In Progress'),
                'Final': games.filter(g => g.status === 'Final'),
                'Warmup': games.filter(g => g.status === 'Warmup'),
                'Scheduled': games.filter(g => g.status === 'Preview' || g.status === 'Scheduled')
            };
            
            Object.entries(gamesByStatus).forEach(([status, statusGames]) => {
                if (statusGames.length === 0) return;
                
                const statusColors = {
                    'Live/In Progress': '#ff9900',
                    'Final': '#4CAF50',
                    'Warmup': '#2196F3',
                    'Scheduled': '#666'
                };
                
                const statusEmojis = {
                    'Live/In Progress': 'üî¥',
                    'Final': '‚úÖ',
                    'Warmup': 'üî•',
                    'Scheduled': 'üìÖ'
                };
                
                html += `<div style="margin-bottom: 15px;">`;
                html += `<h5 style="color: ${statusColors[status]}; margin: 0 0 8px 0; font-size: 0.9em;">${statusEmojis[status]} ${status} (${statusGames.length})</h5>`;
                
                statusGames.forEach(game => {
                    const gameTime = game.gameTime ? new Date(game.gameTime).toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit'
                    }) : '';
                    
                    html += `
                        <div style="background: #1a1a1a; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 3px solid ${statusColors[status]};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-weight: bold; color: white;">
                                    ${game.awayTeam} @ ${game.homeTeam}
                                </div>
                                <div style="text-align: right;">
                                    ${game.awayScore !== undefined && game.homeScore !== undefined ? 
                                        `<span style="color: #4CAF50; font-weight: bold; font-size: 1.1em;">${game.awayScore} - ${game.homeScore}</span>` : 
                                        `<span style="color: #888;">${gameTime}</span>`
                                    }
                                </div>
                            </div>
                            ${game.inning ? `<div style="color: #888; font-size: 0.8em; margin-top: 4px;">${game.inning}</div>` : ''}
                            ${game.gameId ? `<div style="color: #666; font-size: 0.7em; font-family: monospace;">${game.gameId}</div>` : ''}
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            html += `</div>`;
            
            contentDiv.innerHTML = html;
            progressDiv.style.display = 'block';
        }
        
        function updateStats(stats) {
            console.log('üìä Updating stats with:', stats);
            
            // Handle both direct stats object and nested stats object
            const actualStats = stats.stats || stats;
            
            document.getElementById('total-entries').textContent = actualStats.totalEntries || 0;
            document.getElementById('prize-pool').textContent = (actualStats.prizePool || 0) + ' NUTS';
            document.getElementById('contest-status').textContent = 
                (actualStats.totalEntries || 0) >= 2 ? 'Active' : 'Needs ' + (2 - (actualStats.totalEntries || 0)) + ' more';
            
            // Handle avgScore safely
            const avgScore = actualStats.avgScore || actualStats.averageScore || 0;
            document.getElementById('avg-score').textContent = Number(avgScore).toFixed(1);
        }
        
        function updateEntriesTable(entries) {
            if (currentContestType === 'nfl') {
                updateNFLEntriesTable(entries);
                return;
            }
            
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for this date
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort entries by score (descending) for leaderboard effect
            const sortedEntries = [...entries].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            // Check if scores are calculated and from database
            const hasScores = sortedEntries.some(entry => entry.score !== undefined);
            const contestDate = document.getElementById('contest-date').value;
            const scoreSource = hasScores ? (entries[0]?.lastScoreUpdate ? 'database' : 'calculated') : 'none';
            
            tbody.innerHTML = sortedEntries.map((entry, index) => {
                // Create detailed picks display
                const picksHtml = formatPicksDisplay(entry.picks || {});
                
                // Determine rank styling
                const rank = index + 1;
                const rankStyle = rank === 1 ? 'color: #FFD700; font-weight: bold;' : // Gold
                                 rank === 2 ? 'color: #C0C0C0; font-weight: bold;' : // Silver  
                                 rank === 3 ? 'color: #CD7F32; font-weight: bold;' : // Bronze
                                 'color: #888;';
                
                // Score display with indicators
                let scoreDisplay = '';
                if (entry.score !== undefined) {
                    const scoreIndicator = scoreSource === 'database' ? 'üíæ' : 'üîÑ';
                    const scoreTooltip = scoreSource === 'database' ? 'Score loaded from database' : 'Score calculated this session';
                    scoreDisplay = `<span class="score-badge" title="${scoreTooltip}" style="font-size: 1.1em; ${rank <= 3 ? 'background: ' + (rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32') + '; color: #000;' : ''}">${entry.score} ${scoreIndicator}</span>`;
                } else {
                    scoreDisplay = '<span style="color: #666;">Not calculated</span>';
                }
                
                return `
                <tr style="${rank <= 3 && hasScores ? 'background: rgba(255, 215, 0, 0.05);' : ''} cursor: pointer;" onclick="showDetailedPicks('${entry.id}')" class="clickable-row">
                    <td style="font-family: monospace; font-size: 0.85em;">
                        <span style="${rankStyle}">#${rank}</span><br>
                        ${entry.id.substring(0, 8)}...
                    </td>
                    <td>
                        <strong>${entry.userName}</strong>
                        ${rank <= 3 && hasScores ? `<br><small style="${rankStyle}">${rank === 1 ? 'üëë Leader' : rank === 2 ? 'ü•à 2nd Place' : 'ü•â 3rd Place'}</small>` : ''}
                    </td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;" onclick="event.stopPropagation();">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview" style="max-width: 200px;">
                        ${picksHtml}
                        <div style="margin-top: 5px; font-size: 0.7em; color: #ffa500;">üëÜ Click row for details</div>
                    </td>
                    <td style="text-align: center;">
                        <strong>${entry.tiebreakerRuns || 0}</strong> runs
                    </td>
                    <td style="text-align: center;">
                        ${scoreDisplay}
                    </td>
                    <td style="text-align: center;">${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                        ${entry.status === 'won' && entry.prizeWon > 0 ? `
                            <br><small style="color: #4CAF50;">Won ${entry.prizeWon} NUTS</small>
                        ` : ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${new Date(entry.timestamp || entry.paymentTimestamp).toLocaleTimeString()}
                    </td>
                </tr>
            `;
            }).join('');
            
            // Add status message about scores at the top
            if (hasScores) {
                const statusMessage = scoreSource === 'database' ? 
                    'üíæ Scores loaded from database (persistent)' : 
                    'üîÑ Scores calculated this session';
                    
                const statusRow = `
                    <tr style="background: rgba(76, 175, 80, 0.1);">
                        <td colspan="10" style="text-align: center; padding: 10px; color: #4CAF50; font-size: 0.9em;">
                            ${statusMessage} ‚Ä¢ ${sortedEntries.length} entries sorted by score
                        </td>
                    </tr>
                `;
                tbody.innerHTML = statusRow + tbody.innerHTML;
            }
        }
        
        // NEW FUNCTION: Format picks for display
        function formatPicksDisplay(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<span style="color: #666;">No picks</span>';
            }
            
            let html = `<div style="font-size: 0.8em;">`;
            let pickCount = 0;
            const maxDisplayPicks = 3; // Show first 3 picks, then "..."
            
            Object.entries(picks).forEach(([gameId, pick]) => {
                if (pickCount < maxDisplayPicks) {
                    // Try to get team names from the game ID or use generic names
                    const teams = getTeamNamesFromGameId(gameId);
                    const pickedTeam = pick === 'home' ? teams.home : teams.away;
                    
                    html += `
                        <div style="margin: 2px 0; padding: 2px 4px; background: #2a2a2a; border-radius: 3px; display: flex; justify-content: space-between;">
                            <span style="color: #888; font-size: 0.7em;">${teams.away} @ ${teams.home}</span>
                            <span style="color: #ffa500; font-weight: bold;">${pickedTeam}</span>
                        </div>
                    `;
                }
                pickCount++;
            });
            
            if (pickCount > maxDisplayPicks) {
                html += `<div style="color: #666; font-size: 0.7em; text-align: center; margin-top: 4px;">...and ${pickCount - maxDisplayPicks} more</div>`;
            }
            
            html += `</div>`;
            return html;
        }
        
        // NEW FUNCTION: Fetch real game results from MLB API
        async function fetchRealGameResults(contestDate = null, showAlert = true) {
            const dateToCheck = contestDate || document.getElementById('contest-date').value;
            
            if (!dateToCheck) {
                if (showAlert) alert('Please select a date first');
                return {};
            }
            
            try {
                console.log(`üîÑ Fetching real MLB game results for ${dateToCheck}...`);
                
                if (showAlert) {
                    document.body.style.cursor = 'wait';
                }
                
                // Initialize MLB Schedule API if not available
                if (!window.mlbSchedule) {
                    console.log('üì° Loading MLB Schedule API...');
                    window.mlbSchedule = new MLBScheduleFree();
                }
                
                // Create date object properly to avoid timezone issues
                const dateParts = dateToCheck.split('-');
                const gameDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                
                console.log(`üóìÔ∏è Processing game results for: ${dateToCheck}`);
                console.log(`üóìÔ∏è Created date object: ${gameDate.toDateString()} (${gameDate.toISOString()})`);
                
                // Use the new getGameResults method that returns processed results
                const gameResults = await window.mlbSchedule.getGameResults(gameDate);
                
                // Always get games to show progress (regardless of completed games)
                const allGames = await window.mlbSchedule.getGamesForDate(gameDate);
                updateGameProgressDisplay(allGames);
                
                const completedGames = Object.keys(gameResults).filter(key => key !== 'lastGameRuns').length;
                
                console.log(`üìÖ Found ${completedGames} completed games for ${dateToCheck}`);
                
                // Store the last game total runs globally for tiebreaker calculations
                window.lastGameActualRuns = gameResults.lastGameRuns || 0;
                console.log(`üèÉ Last game total runs for tiebreaker: ${window.lastGameActualRuns}`);
                
                if (completedGames === 0) {
                    if (showAlert) {
                        const games = await window.mlbSchedule.getGamesForDate(gameDate);
                        const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
                        const notStarted = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
                        
                        alert(`üìä Game Status Update for ${dateToCheck}:\n\n‚úÖ Completed: 0\nüîÑ In Progress: ${inProgress}\nüìÖ Not Started: ${notStarted}\n\nNo games have finished yet. Check back later!`);
                    }
                    return {};
                }
                
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    
                    alert(`üìä Game Results Updated!\n\n‚úÖ Completed Games: ${completedGames}\nüèÉ Total Runs: ${gameResults.lastGameRuns || 0}\n\nContest scores will be updated automatically.`);
                    
                    // Automatically recalculate scores for entries
                    await updateEntryScores(gameResults);
                    loadContestData(); // Refresh the display
                }
                
                return gameResults;
                
            } catch (error) {
                console.error('‚ùå Failed to fetch real game results:', error);
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    alert(`Failed to fetch game results: ${error.message}\n\nPlease check your internet connection and try again.`);
                }
                return {};
            }
        }
        
        // ENHANCED FUNCTION: Display contest winners with proper data structure handling
        function displayContestWinners(winners, contestDate, prizePool) {
            if (!winners || winners.length === 0) {
                console.log('‚ö†Ô∏è No winners to display');
                return;
            }
            
            console.log('üèÜ Displaying contest winners:', winners);
            
            // Validate that winners is an array
            if (!Array.isArray(winners)) {
                console.error('‚ùå Winners is not an array:', typeof winners, winners);
                alert('Error: Winners data is not in the expected format. Check console for details.');
                return;
            }
            
            if (winners.length === 0) {
                console.warn('‚ö†Ô∏è No winners to display');
                alert('No winners found for this contest.');
                return;
            }
            
            // Debug: Log the first winner's properties to see what fields are available
            if (winners.length > 0) {
                console.log('üîç First winner object structure:', Object.keys(winners[0]));
                console.log('üîç First winner full object:', winners[0]);
                console.log('üîç Checking wallet fields in winner object:');
                console.log('  - walletAddress:', winners[0].walletAddress);
                console.log('  - playerWallet:', winners[0].playerWallet);
                console.log('  - wallet:', winners[0].wallet);
                console.log('  - xrpAddress:', winners[0].xrpAddress);
                
                // Also check if winner has entry object
                if (winners[0].entry) {
                    console.log('üîç Checking wallet fields in entry object:');
                    console.log('  - entry.walletAddress:', winners[0].entry.walletAddress);
                    console.log('  - entry.playerWallet:', winners[0].entry.playerWallet);
                    console.log('  - entry.wallet:', winners[0].entry.wallet);
                    console.log('  - entry.xrpAddress:', winners[0].entry.xrpAddress);
                }
            }
            
            const winnersDisplay = document.getElementById('winners-display');
            const winnersContent = document.getElementById('winners-content');
            
            // Create winners HTML
            let winnersHtml = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="color: #4CAF50; font-size: 1.2em; margin-bottom: 10px;">
                        Contest Date: ${contestDate} | Total Prize Pool: ${prizePool} NUTS
                    </div>
                    <div style="color: #888; font-size: 0.9em;">
                        Winners calculated based on game results and tiebreaker
                    </div>
                </div>
                
                <div style="display: grid; gap: 15px;">
            `;
            
            winners.forEach((winner, index) => {
                const place = winner.place || (index + 1);
                const medal = place === 1 ? 'ü•á' : place === 2 ? 'ü•à' : place === 3 ? 'ü•â' : 'üèÖ';
                const bgColor = place === 1 ? 'rgba(255, 215, 0, 0.1)' : 
                               place === 2 ? 'rgba(192, 192, 192, 0.1)' : 
                               place === 3 ? 'rgba(205, 127, 50, 0.1)' : 'rgba(136, 136, 136, 0.1)';
                
                // Access entry data correctly - winner.entry contains the entry object
                const entry = winner.entry || winner;
                const walletAddress = entry.walletAddress || entry.playerWallet || entry.wallet || entry.xrpAddress ||
                                    winner.walletAddress || winner.playerWallet || winner.wallet || winner.xrpAddress;
                const score = entry.score !== undefined ? entry.score : winner.score || 0;
                const tiebreakerRuns = entry.tiebreakerRuns || entry.tiebreakerPoints || winner.tiebreakerRuns || winner.tiebreakerPoints || 0;
                const prize = winner.prize || winner.prizeWon || entry.prizeWon || 0;
                const userName = entry.userName || entry.name || winner.userName || winner.name || 'Anonymous Player';
                const twitterHandle = entry.twitterHandle || winner.twitterHandle;
                const entryId = entry.id || entry.entryId || winner.id || winner.entryId;
                
                winnersHtml += `
                    <div style="
                        background: ${bgColor}; 
                        border: 2px solid ${place <= 3 ? '#4CAF50' : '#666'}; 
                        border-radius: 8px; 
                        padding: 15px; 
                        display: grid; 
                        grid-template-columns: auto 1fr auto auto; 
                        align-items: center; 
                        gap: 15px;
                    ">
                        <div style="font-size: 2em;">${medal}</div>
                        <div>
                            <div style="color: #4CAF50; font-weight: bold; font-size: 1.1em;">
                                ${userName}
                            </div>
                            <div style="color: #888; font-size: 0.9em; margin: 5px 0;">
                                ${twitterHandle ? `X: ${twitterHandle}` : 'No X handle'}
                            </div>
                            ${walletAddress ? `
                                <div style="color: #888; font-size: 0.85em; background: rgba(76, 175, 80, 0.1); padding: 4px 8px; border-radius: 4px; margin-top: 8px;">
                                    <div style="color: #888; font-size: 0.8em; margin-bottom: 2px;">Wallet Address:</div>
                                    <div style="word-break: break-all; line-height: 1.3; font-family: monospace; color: #4CAF50;">
                                        ${walletAddress}
                                    </div>
                                </div>
                            ` : `
                                <div style="color: #ff4444; font-size: 0.85em; background: rgba(255, 68, 68, 0.1); padding: 4px 8px; border-radius: 4px; margin-top: 8px;">
                                    ‚ùå No wallet address provided
                                </div>
                            `}
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #4CAF50; font-weight: bold;">Score: ${score}</div>
                            <div style="color: #888; font-size: 0.9em;">Tiebreaker: ${tiebreakerRuns}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #4CAF50; font-weight: bold; font-size: 1.2em;">
                                ${prize} NUTS
                            </div>
                            <div style="color: #888; font-size: 0.8em;">${place === 1 ? '50%' : place === 2 ? '30%' : place === 3 ? '20%' : '0%'} of pool</div>
                        </div>
                    </div>
                `;
            });
            
            winnersHtml += `
                </div>
                
                <!-- Action Buttons -->
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="hideWinners()" 
                            style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-right: 10px;">
                        Hide Winners
                    </button>
                    <button onclick="exportWinners()" 
                            style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">
                        üìã Export Winners List
                    </button>
                </div>
            `;
            
            winnersContent.innerHTML = winnersHtml;
            winnersDisplay.style.display = 'block';
            
            // Scroll to winners display
            winnersDisplay.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // NEW FUNCTION: Hide winners display
        function hideWinners() {
            document.getElementById('winners-display').style.display = 'none';
        }
        
        // NEW FUNCTION: Export winners list
        function exportWinners() {
            const winnersContent = document.getElementById('winners-content');
            if (!winnersContent.innerHTML.trim()) {
                alert('No winners data to export');
                return;
            }
            
            // Extract winner data from current entries
            const winners = currentEntries
                .filter(entry => entry.prizeWon && entry.prizeWon > 0)
                .sort((a, b) => (b.prizeWon || 0) - (a.prizeWon || 0));
            
            if (winners.length === 0) {
                alert('No winners found to export');
                return;
            }
            
            // Create CSV
            const headers = ['Place', 'Player Name', 'X Handle', 'Wallet Address', 'Score', 'Tiebreaker', 'Prize (NUTS)', 'Entry ID'];
            const rows = winners.map((winner, index) => [
                (index + 1).toString(),
                winner.userName || winner.name || 'Anonymous',
                winner.twitterHandle || '',
                winner.walletAddress || '',
                (winner.score || 0).toString(),
                (winner.tiebreakerRuns || winner.tiebreakerPoints || 0).toString(),
                (winner.prizeWon || 0).toString(),
                winner.id || winner.entryId || ''
            ]);
            
            const csv = [headers, ...rows].map(row => 
                row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
            ).join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `contest_winners_${document.getElementById('contest-date').value}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('üìã Winners list exported successfully');
        }
        
        // Enhanced scoring function with detailed logging
        async function updateEntryScores(gameResults) {
            if (currentEntries.length === 0 || Object.keys(gameResults).length === 0) {
                return;
            }
            
            console.log('üèÜ Updating entry scores with real game results...');
            console.log('üéÆ Game Results:', gameResults);
            console.log('üìã Available game IDs in results:', Object.keys(gameResults));
            
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                console.error('‚ùå No contest date selected');
                return;
            }
            
            try {
                // Use enhanced backend for Firebase-compatible score persistence
                console.log('üîß Initializing enhanced backend for Firebase score persistence...');
                const enhancedBackend = new ContestBackendEnhanced();
                await enhancedBackend.init();
                
                // Use the enhanced backend's updateGameResults method for CORS-compliant Firebase operations
                console.log('ÔøΩ Persisting scores to Firebase via enhanced backend...');
                const result = await enhancedBackend.updateGameResults(contestDate, gameResults);
                
                if (result && result.allEntries) {
                    // Update current entries with the persisted scores from Firebase
                    currentEntries = result.allEntries;
                    console.log(`‚úÖ Successfully persisted ${result.allEntries.length} entry scores to Firebase`);
                    
                    // Clear temporary scores since we now have persisted data
                    if (window.tempScores) {
                        delete window.tempScores;
                    }
                    
                    // Display winner information if available
                    if (result.winners && result.winners.length > 0) {
                        console.log('üèÜ Contest winners:', result.winners);
                        result.winners.forEach((winner, index) => {
                            console.log(`${index + 1}. ${winner.entry?.userName || winner.userName} - Score: ${winner.entry?.score || winner.score} - Prize: ${winner.prize} NUTS`);
                        });
                    }
                    
                    // Show status information
                    if (result.status === 'cancelled') {
                        console.warn('‚ö†Ô∏è Contest cancelled:', result.reason);
                        alert(`Contest cancelled: ${result.reason}\nEntries: ${result.totalEntries}, Minimum required: ${result.minimumRequired}`);
                    } else if (result.status === 'completed') {
                        console.log('üéâ Contest completed successfully');
                        if (result.totalPrizePool) {
                            console.log(`üí∞ Total prize pool: ${result.totalPrizePool} NUTS`);
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è No entries updated - this may indicate an issue with Firebase persistence');
                }
                
                // Refresh the display using enhanced display if available
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                } else {
                    updateEntriesTable(currentEntries);
                }
                
                // Reload the contest data to reflect the updated scores
                await loadContestData();
                
                console.log('üîÑ Contest data reloaded with updated scores from Firebase');
                
            } catch (error) {
                console.error('‚ùå Failed to persist scores to Firebase:', error);
                
                // Fallback: Calculate and display scores locally without Firebase persistence
                console.log('üîÑ Falling back to local score calculation...');
                
                try {
                    let updatedCount = 0;
                    
                    // Calculate scores for each entry locally
                    for (const entry of currentEntries) {
                        if (!entry.picks) {
                            console.log(`‚ùå ${entry.userName}: No picks found`);
                            continue;
                        }
                        
                        let newScore = 0;
                        console.log(`üîç Processing ${entry.userName}...`);
                        
                        // Calculate score based on real game results
                        Object.keys(entry.picks).forEach(gameId => {
                            const userPick = entry.picks[gameId]; // 'home' or 'away'
                            
                            // Try exact match first
                            let gameResult = gameResults[gameId];
                            
                            // If no exact match, try to find a similar game ID
                            if (!gameResult) {
                                const possibleMatches = Object.keys(gameResults).filter(resultGameId => {
                                    if (resultGameId.includes(gameId) || gameId.includes(resultGameId)) {
                                        return true;
                                    }
                                    
                                    const extractGamePk = (id) => {
                                        const match = id.match(/(\d+)$/);
                                        return match ? match[1] : null;
                                    };
                                    
                                    const userGamePk = extractGamePk(gameId);
                                    const resultGamePk = extractGamePk(resultGameId);
                                    
                                    return userGamePk && resultGamePk && userGamePk === resultGamePk;
                                });
                                
                                if (possibleMatches.length > 0) {
                                    gameResult = gameResults[possibleMatches[0]];
                                    console.log(`  üîÑ Matched ${gameId} to ${possibleMatches[0]}`);
                                }
                            }
                            
                            if (gameResult && (gameResult.status === 'completed' || gameResult.status === 'Final')) {
                                const isCorrect = userPick === gameResult.winner;
                                if (isCorrect) {
                                    newScore++;
                                }
                            }
                        });
                        
                        const oldScore = entry.score || 0;
                        entry.score = newScore;
                        
                        console.log(`üìä ${entry.userName}: ${oldScore} ‚Üí ${newScore} points`);
                        updatedCount++;
                        
                        // Store in temporary scores object for display
                        if (!window.tempScores) {
                            window.tempScores = {};
                        }
                        window.tempScores[entry.id] = {
                            score: entry.score,
                            userName: entry.userName,
                            timestamp: Date.now()
                        };
                    }
                    
                    console.log(`‚úÖ Calculated ${updatedCount} entry scores locally (NOT saved to Firebase)`);
                    
                    // Refresh the display
                    if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                        window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                    } else {
                        updateEntriesTable(currentEntries);
                    }
                    
                    alert(`‚ö†Ô∏è Firebase Error: ${error.message}\n\nScores calculated correctly but not saved to database.\nDisplaying local calculations only.`);
                    
                } catch (fallbackError) {
                    console.error('‚ùå Fallback calculation also failed:', fallbackError);
                    alert(`Failed to calculate scores: ${fallbackError.message}`);
                }
            }
        }
        
        // NEW FUNCTION: Show detailed picks modal
        function showDetailedPicks(entryId) {
            const entry = currentEntries.find(e => e.id === entryId);
            if (!entry) return;
            
            // Create or show the detailed picks modal
            let modal = document.getElementById('detailed-picks-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'detailed-picks-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.8);
                    z-index: 1001;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div style="background: #1a1a1a; border: 2px solid #ffa500; border-radius: 12px; padding: 30px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
                    <button onclick="closeDetailedPicks()" style="position: absolute; top: 10px; right: 10px; background: #ffa500; border: none; color: #000; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-weight: bold;">√ó</button>
                    
                    <h2 style="color: #ffa500; margin-bottom: 20px;">üìã Detailed Picks</h2>
                    
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 10px 0; color: #fff;">${entry.userName}</h3>
                        <div style="font-size: 0.9em; color: #888;">
                            Entry ID: ${entry.id}<br>
                            Score: <strong style="color: #4CAF50;">${entry.score || 0}</strong> correct picks<br>
                            Tiebreaker: ${entry.tiebreakerRuns || 0} runs
                        </div>
                    </div>
                    
                    <div id="detailed-picks-content">
                        ${formatDetailedPicks(entry.picks || {})}
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        function closeDetailedPicks() {
            const modal = document.getElementById('detailed-picks-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function formatDetailedPicks(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<div style="text-align: center; color: #888; padding: 20px;">No picks found</div>';
            }
            
            let html = `<div style="font-size: 0.9em;">`;
            
            Object.entries(picks).forEach(([gameId, pick], index) => {
                const teams = getTeamNamesFromGameId(gameId);
                const pickedTeam = pick === 'home' ? teams.home : teams.away;
                
                html += `
                    <div style="background: #2a2a2a; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 3px solid #ffa500;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="color: #fff;">Game ${index + 1}</strong><br>
                                <span style="color: #888; font-size: 0.8em;">${teams.away} @ ${teams.home}</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffa500; font-weight: bold; font-size: 1.1em;">Picked: ${pickedTeam}</div>
                                <div style="color: #666; font-size: 0.7em; font-family: monospace;">${gameId}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            return html;
        }
        
        // Initialize page when loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize with MLB contest as default
        });

        // ===============================================
        // SIMPLIFIED WORKFLOW FUNCTIONS
        // ===============================================
        
        // Toggle advanced controls visibility
        function toggleAdvancedControls() {
            const controls = document.getElementById('advanced-controls');
            if (controls.style.display === 'none') {
                controls.style.display = 'block';
            } else {
                controls.style.display = 'none';
            }
        }

        // NEW SIMPLIFIED WORKFLOW FUNCTIONS
        
        // Simplified function: Calculate scores and update the entries table immediately
        async function calculateAndUpdateScores() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üßÆ Starting score calculation and table update...');
                
                // 1. Load entries if not already loaded
                if (currentEntries.length === 0) {
                    console.log('üìä Loading entries first...');
                    await loadContestData();
                }

                // 2. Fetch real game results
                console.log('‚öæ Fetching game results...');
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }

                // 3. Use the enhanced backend method that calculates scores AND saves to Firebase
                console.log('üìä Using enhancedBackend.updateGameResults method...');
                if (!window.enhancedBackend) {
                    console.log('üöÄ Creating enhanced backend instance...');
                    window.enhancedBackend = new ContestBackendEnhanced();
                    await window.enhancedBackend.init();
                }
                
                const winners = await window.enhancedBackend.updateGameResults(contestDate, gameResults);

                // 4. Reload contest data to get the updated scores from Firebase
                console.log('üìä Reloading contest data with updated scores...');
                await loadContestData();

                // 5. Update the entries table immediately
                console.log('üìä Updating entries table...');
                updateEntriesTable(currentEntries);

                // 6. Update stats
                const stats = {
                    totalEntries: currentEntries.length,
                    prizePool: currentEntries.length * 50,
                    avgScore: currentEntries.reduce((sum, e) => sum + (e.score || 0), 0) / currentEntries.length
                };
                updateStats(stats);

                console.log('‚úÖ Scores calculated and saved successfully!');
                alert(`‚úÖ Scores calculated and saved for ${currentEntries.length} entries!\n\nThe leaderboard now shows the correct scores.`);

            } catch (error) {
                console.error('‚ùå Failed to calculate scores:', error);
                alert('Failed to calculate scores: ' + error.message);
            }
        }

        // Simplified function: Resolve contest and show winners (no payouts)
        async function resolveContestAndShowWinners() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            const minimumEntries = window.config?.contest?.minimumEntries || 4;

            if (currentEntries.length < minimumEntries) {
                alert(`Need at least ${minimumEntries} entries to resolve contest. Current: ${currentEntries.length}`);
                return;
            }

            try {
                console.log('üèÜ Starting contest resolution...');

                // 1. Fetch real game results
                console.log('‚öæ Fetching game results...');
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot resolve contest until games finish.');
                    return;
                }

                // 2. Use enhanced backend to calculate scores and determine winners
                console.log('ü•á Calculating scores and determining winners...');
                if (!window.enhancedBackend) {
                    console.log('üöÄ Creating enhanced backend instance...');
                    window.enhancedBackend = new ContestBackendEnhanced();
                    await window.enhancedBackend.init();
                }
                
                const result = await window.enhancedBackend.updateGameResults(contestDate, gameResults);

                // 3. Reload contest data to get updated scores
                console.log('üìä Reloading contest data with final scores...');
                await loadContestData();

                // 4. Calculate winners with proper backend logic
                console.log('ÔøΩ Calculating contest winners...');
                if (!window.contestBackend) {
                    window.contestBackend = new ContestBackend();
                    await window.contestBackend.init();
                }
                
                const winners = window.contestBackend.calculateWinners(currentEntries, gameResults.lastGameRuns || 0);
                console.log('üéØ Winners calculated:', winners);

                // 5. Display winners banner
                if (winners && winners.winners && winners.winners.length > 0) {
                    console.log('üéâ Displaying winners banner...');
                    const prizePool = currentEntries.length * 50;
                    displayContestWinners(winners.winners, contestDate, prizePool);
                } else {
                    console.log('‚ö†Ô∏è No winners to display - insufficient entries or incomplete games');
                }

                // 6. Update entries table to show final results
                updateEntriesTable(currentEntries);


                console.log('ÔøΩ Displaying contest winners...');


                console.log('‚úÖ Contest resolved successfully!');
                alert(`‚úÖ Contest resolved successfully!\n\nWinners determined and displayed.\nScores have been saved to the database.`);

            } catch (error) {
                console.error('‚ùå Failed to resolve contest:', error);
                alert('Failed to resolve contest: ' + error.message);
            }
        }

        // Enhanced function to save scores to Firebase database for persistence
        async function saveScoresToFirebase(contestDate) {
            console.log('üíæ Scores automatically saved via enhanced backend during calculation');
            console.log('‚úÖ Contest scores are persisted in Firebase database');
            
            // The enhanced backend.updateGameResults already saved the scores during the calculation process
            // No additional saving needed here - this function is just for logging/status
        }

        // Enhanced function to save contest resolution
        async function saveContestResolution(contestDate, winners) {
            console.log('üíæ Contest resolution automatically saved via enhanced backend');
            console.log('‚úÖ Winners and final results are persisted in Firebase');
            
            // The enhanced backend.updateGameResults already handled the contest resolution
            // No additional saving needed here - this function is just for logging/status
        }

        // Enhanced function to determine winners with proper tiebreaker handling
        function determineWinners(entries) {
            if (!entries || entries.length === 0) return [];

            // Sort by score (descending), then by tiebreaker (ascending - closest to actual)
            const sortedEntries = [...entries].sort((a, b) => {
                const scoreA = a.score || 0;
                const scoreB = b.score || 0;
                
                if (scoreA !== scoreB) {
                    return scoreB - scoreA; // Higher score wins
                }
                
                // If scores are tied, use tiebreaker (lower tiebreaker difference wins)
                const tiebreakerA = a.tiebreakerRuns || 0;
                const tiebreakerB = b.tiebreakerRuns || 0;
                
                // This would need actual total runs to determine winner properly
                // For now, lower tiebreaker wins (assuming it's closer to actual)
                return tiebreakerA - tiebreakerB;
            });

            // Calculate prizes (50% to 1st, 30% to 2nd, 20% to 3rd)
            const totalPrizePool = entries.length * 50;
            const prizes = [
                Math.floor(totalPrizePool * 0.5), // 1st place: 50%
                Math.floor(totalPrizePool * 0.3), // 2nd place: 30%
                Math.floor(totalPrizePool * 0.2)  // 3rd place: 20%
            ];

            // Create winner objects
            const winners = sortedEntries.slice(0, 3).map((entry, index) => ({
                place: index + 1,
                entry: entry,
                prize: prizes[index] || 0
            }));

            // Update the original entries with prize information
            winners.forEach(winner => {
                const originalEntry = entries.find(e => e.id === winner.entry.id);
                if (originalEntry) {
                    originalEntry.prizeWon = winner.prize;
                    originalEntry.status = 'won';
                    originalEntry.place = winner.place;
                }
            });

            return winners;
        }

        // All-in-one contest processing: Load data ‚Üí Fetch games ‚Üí Calculate scores ‚Üí Save to DB ‚Üí Update display
        async function processFullContest() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üöÄ Starting full contest processing...');
                
                // Step 1: Load contest data
                console.log('üìã Step 1: Loading contest data...');
                await loadContestData();
                
                if (currentEntries.length === 0) {
                    alert('No entries found for this date. Contest processing cancelled.');
                    return;
                }

                // Step 2: Fetch real game results
                console.log('üéÆ Step 2: Fetching game results...');
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot process contest until games finish.');
                    return;
                }

                // Step 3: Calculate and save scores
                console.log('üßÆ Step 3: Calculating scores...');
                await calculateScoresWithGameResults(gameResults);

                // Step 4: Save to database
                console.log('üíæ Step 4: Saving scores to database...');
                await saveScoresToDatabaseWithResults();

                // Step 5: Refresh display
                console.log('üîÑ Step 5: Refreshing display...');
                await loadContestData();

                alert('‚úÖ Contest processing complete! Scores calculated and saved to database.');

            } catch (error) {
                console.error('‚ùå Contest processing failed:', error);
                alert(`Contest processing failed: ${error.message}`);
            }
        }

        // Calculate scores only (without resolving winners)
        async function calculateScoresOnly() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }

            try {
                console.log('üßÆ Calculating scores only...');
                
                // Fetch game results
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }

                // Calculate scores and update entries table
                await calculateScoresWithGameResults(gameResults);
                
                // Save calculated scores to database
                await saveScoresToDatabaseWithResults();

                // Refresh the entries table to show updated scores
                await loadContestData();

                alert('‚úÖ Scores calculated and saved! Check the entries table for updated scores.');

            } catch (error) {
                console.error('‚ùå Score calculation failed:', error);
                alert(`Score calculation failed: ${error.message}`);
            }
        }

        // Helper function to calculate scores with game results
        async function calculateScoresWithGameResults(gameResults) {
            console.log('üéØ Calculating scores for all entries...');
            
            let updatedCount = 0;
            
            for (const entry of currentEntries) {
                if (!entry.picks) continue;
                
                let score = 0;
                
                // Calculate score based on correct picks
                for (const [gameId, pick] of Object.entries(entry.picks)) {
                    if (gameResults[gameId] && gameResults[gameId].result === pick) {
                        score++;
                    }
                }
                
                // Update entry with calculated score
                entry.score = score;
                updatedCount++;
                
                console.log(`üìä ${entry.userName}: ${score} correct picks`);
            }
            
            console.log(`‚úÖ Updated scores for ${updatedCount} entries`);
            
            // Update the entries table immediately
            updateEntriesTable(currentEntries);
        }

        // Enhanced function to save scores to database with better persistence
        async function saveScoresToDatabaseWithResults() {
            if (currentEntries.length === 0) {
                alert('No entries to save');
                return;
            }

            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üíæ Calculating and saving scores using enhanced backend...');
                
                // Get real game results first
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }
                
                // Use the enhanced backend method that calculates scores AND saves to Firebase
                console.log('üìä Using enhancedBackend.updateGameResults method...');
                if (!window.enhancedBackend) {
                    console.log('üöÄ Creating enhanced backend instance...');
                    window.enhancedBackend = new ContestBackendEnhanced();
                    await window.enhancedBackend.init();
                }
                
                const winners = await window.enhancedBackend.updateGameResults(contestDate, gameResults);
                
                // Reload contest data to get updated scores
                await loadContestData();
                
                console.log(`‚úÖ Successfully calculated and saved ${currentEntries.length} scores to database`);
                alert(`‚úÖ Successfully calculated and saved ${currentEntries.length} scores to database`);

            } catch (error) {
                console.error('‚ùå Failed to calculate and save scores:', error);
                alert(`Failed to calculate and save scores: ${error.message}`);
            }
        }

        // Final contest resolution with winner determination and prize distribution
        async function resolveContestFinal() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }

            // Check if scores are calculated
            const hasScores = currentEntries.some(entry => entry.score !== undefined);
            if (!hasScores) {
                const shouldCalculate = confirm('Scores not calculated yet. Calculate scores first?');
                if (shouldCalculate) {
                    await calculateScoresOnly();
                } else {
                    return;
                }
            }

            try {
                console.log('üèÜ Finalizing contest and determining winners...');
                
                // Use the enhanced contest resolution
                if (window.resolveContest) {
                    const result = await window.resolveContest(contestDate);
                    
                    if (result && result.winners) {
                        // Display the winners
                        displayContestWinners(result.winners, contestDate, result.totalPrizePool || 0);
                        
                        // Show success message
                        alert(`üèÜ Contest finalized successfully!\n\nWinners: ${result.winners.length}\nTotal Prize Pool: ${result.totalPrizePool || 0} NUTS\n\nCheck the winners section above for payout details.`);
                        
                        // Reload the data to show final results
                        await loadContestData();
                    } else {
                        alert('Contest resolution completed, but no result details available. Please check the console for more information.');
                    }
                } else {
                    throw new Error('Contest resolution function not available');
                }

            } catch (error) {
                console.error('‚ùå Failed to finalize contest:', error);
                alert(`Failed to finalize contest: ${error.message}`);
            }
        }

        // Enhanced loadContestData to check for saved scores
        const originalLoadContestData = loadContestData;
        loadContestData = async function() {
            await originalLoadContestData();
            
            // Check for locally saved scores as backup
            const contestDate = document.getElementById('contest-date').value;
            if (contestDate) {
                const savedScores = localStorage.getItem(`scores_${contestDate}`);
                if (savedScores) {
                    try {
                        const scoresData = JSON.parse(savedScores);
                        console.log('üìã Found locally saved scores:', scoresData);
                        
                        // Apply saved scores to current entries if they don't have scores
                        currentEntries.forEach(entry => {
                            if (entry.score === undefined) {
                                const savedEntry = scoresData.entries.find(saved => saved.id === entry.id);
                                if (savedEntry) {
                                    entry.score = savedEntry.score;
                                    console.log(`‚úÖ Restored score for ${entry.userName}: ${entry.score}`);
                                }
                            }
                        });
                        
                        // Update display with restored scores
                        updateEntriesTable(currentEntries);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to restore saved scores:', error);
                    }
                }
            }
        };
        
        // Function to show all picks for an entry
        function showAllPicks(entryId) {
            const entry = currentEntries.find(e => e.id === entryId);
            if (!entry || !entry.gamesDetailed) {
                console.warn('Entry or game details not found:', entryId);
                return;
            }
            
            // Create modal if it doesn't exist
            let modal = document.getElementById('all-picks-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'all-picks-modal';
                modal.style.cssText = `
                    display: none;
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    z-index: 1000;
                    overflow-y: auto;
                `;
                document.body.appendChild(modal);
            }
            
            // Generate all picks display
            const allPicksHtml = entry.gamesDetailed.map(game => {
                const isCorrect = game.isCorrect !== undefined ? game.isCorrect : 
                                (game.result === 'win' || game.result === 'correct');
                const isIncorrect = game.isCorrect === false || 
                                  (game.result === 'loss' || game.result === 'incorrect');
                
                let statusClass = 'pending';
                let statusIcon = '‚è≥';
                let statusText = game.status === 'completed' ? 'Final' : 'Pending';
                
                if (isCorrect) {
                    statusClass = 'correct';
                    statusIcon = '‚úÖ';
                    statusText = 'WIN';
                } else if (isIncorrect) {
                    statusClass = 'incorrect';
                    statusIcon = '‚ùå';
                    statusText = `LOSS${game.actualWinner ? ` (${game.actualWinner})` : ''}`;
                }
                
                return `
                    <div class="all-picks-item ${statusClass}" style="
                        margin: 8px;
                        padding: 12px;
                        border: 1px solid #444;
                        border-radius: 8px;
                        background: #2a2a2a;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        min-width: 300px;
                    ">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #ffa500; margin-bottom: 4px;">
                                ${game.pickedTeam || game.pickedDirection || 'Unknown'}
                            </div>
                            <div style="font-size: 0.9em; color: #ccc;">
                                ${game.awayTeam || 'Away'} @ ${game.homeTeam || 'Home'}
                            </div>
                            ${game.actualScore ? `<div style="font-size: 0.8em; color: #888;">${game.actualScore}</div>` : ''}
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.2em; margin-bottom: 4px;">${statusIcon}</div>
                            <div style="font-size: 0.8em; color: #ccc;">${statusText}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div style="
                    background: #1a1a1a;
                    margin: 50px auto;
                    padding: 20px;
                    border: 2px solid #ffa500;
                    border-radius: 12px;
                    max-width: 800px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #ffa500; margin: 0;">All Picks for ${entry.userName || entry.twitterHandle}</h3>
                        <button onclick="closeAllPicksModal()" style="
                            background: #ff4444;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 16px;
                        ">‚úï Close</button>
                    </div>
                    <div style="margin-bottom: 15px; color: #ccc;">
                        <strong>Score:</strong> ${entry.score || 0} / ${entry.gamesDetailed.length} 
                        <span style="margin-left: 20px;"><strong>Tiebreaker:</strong> ${entry.tiebreakerRuns || 'N/A'} runs</span>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${allPicksHtml}
                    </div>
                </div>
            `;
            
            modal.style.display = 'block';
        }
        
        // Function to close the all picks modal
        function closeAllPicksModal() {
            const modal = document.getElementById('all-picks-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Manual Score Debugger and Fixer
        async function manualScoreDebugger() {
            console.log('üîß MANUAL SCORE DEBUGGER ACTIVATED');
            const contestDate = document.getElementById('contest-date').value;
            
            if (!contestDate || currentEntries.length === 0) {
                alert('Please load contest data first!');
                return;
            }
            
            // Get fresh game results
            console.log('üìÖ Fetching game results for:', contestDate);
            const gameResults = await fetchRealGameResults(contestDate, false);
            
            console.log('üéÆ Available game results:', Object.keys(gameResults));
            console.log('üìä Sample game result:', Object.values(gameResults)[0]);
            
            // Create a detailed report for each player
            const debugReport = [];
            
            for (const entry of currentEntries) {
                console.log(`\nüîç DEBUGGING: ${entry.userName || entry.twitterHandle}`);
                
                const entryReport = {
                    userName: entry.userName || entry.twitterHandle,
                    entryId: entry.id,
                    currentScore: entry.score,
                    calculatedScore: 0,
                    totalPicks: 0,
                    correctPicks: 0,
                    incorrectPicks: 0,
                    pendingPicks: 0,
                    gameDetails: []
                };
                
                if (entry.picks) {
                    const picks = entry.picks;
                    entryReport.totalPicks = Object.keys(picks).length;
                    
                    console.log(`üìä Analyzing ${entryReport.totalPicks} picks for ${entryReport.userName}`);
                    
                    for (const [gameId, pick] of Object.entries(picks)) {
                        console.log(`\nüéÆ Game: ${gameId}, Pick: "${pick}"`);
                        
                        // Try multiple ways to find the game result
                        let gameResult = gameResults[gameId];
                        let gameIdUsed = gameId;
                        
                        if (!gameResult) {
                            // Try extracting game number and rebuilding ID
                            const gameNumber = gameId.split('_').pop();
                            const alternateGameId = `mlb_${contestDate}_${gameNumber}`;
                            gameResult = gameResults[alternateGameId];
                            if (gameResult) {
                                gameIdUsed = alternateGameId;
                                console.log(`üîÑ Found result using alternate ID: ${alternateGameId}`);
                            }
                        }
                        
                        const gameDetail = {
                            originalGameId: gameId,
                            gameIdUsed: gameIdUsed,
                            pick: pick,
                            result: null,
                            status: 'pending',
                            isCorrect: null
                        };
                        
                        if (gameResult) {
                            gameDetail.result = gameResult;
                            gameDetail.status = gameResult.status || 'unknown';
                            
                            if (gameResult.status === 'completed' && gameResult.winner) {
                                gameDetail.isCorrect = (pick === gameResult.winner);
                                
                                if (gameDetail.isCorrect) {
                                    entryReport.calculatedScore++;
                                    entryReport.correctPicks++;
                                    console.log(`‚úÖ CORRECT: picked ${pick}, winner was ${gameResult.winner}`);
                                } else {
                                    entryReport.incorrectPicks++;
                                    console.log(`‚ùå WRONG: picked ${pick}, winner was ${gameResult.winner}`);
                                }
                            } else {
                                entryReport.pendingPicks++;
                                console.log(`‚è≥ PENDING: game not completed`);
                            }
                        } else {
                            entryReport.pendingPicks++;
                            console.log(`‚ùì NO RESULT FOUND`);
                        }
                        
                        entryReport.gameDetails.push(gameDetail);
                    }
                }
                
                console.log(`\nüìä SUMMARY for ${entryReport.userName}:`);
                console.log(`   Current Score: ${entryReport.currentScore}`);
                console.log(`   Calculated Score: ${entryReport.calculatedScore}`);
                console.log(`   Correct: ${entryReport.correctPicks}, Wrong: ${entryReport.incorrectPicks}, Pending: ${entryReport.pendingPicks}`);
                
                debugReport.push(entryReport);
            }
            
            // Display results in a modal
            showDebugModal(debugReport);
            
            // Store debug data globally for manual fixes
            window.debugData = {
                contestDate: contestDate,
                gameResults: gameResults,
                entryReports: debugReport
            };
            
            console.log('üîß Debug data stored in window.debugData');
            console.log('üîß Use manualUpdateScore("username", newScore) to fix scores');
        }
        
        function showDebugModal(debugReport) {
            // Remove any existing debug modal
            const existingModal = document.getElementById('debug-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.id = 'debug-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                background: rgba(0,0,0,0.9); z-index: 10000; 
                overflow-y: auto; padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: #1a1a1a; border: 2px solid #ff6b00; 
                border-radius: 12px; padding: 30px; max-width: 1200px; 
                margin: 0 auto; color: white; position: relative;
            `;
            
            let html = `
                <h2 style="color: #ff6b00; margin-bottom: 20px;">üîß Score Debug Report</h2>
                <button onclick="closeDebugModal()" style="
                    position: absolute; top: 10px; right: 10px; 
                    background: #ff6b00; border: none; color: white; 
                    width: 30px; height: 30px; border-radius: 50%; cursor: pointer;
                    font-size: 18px; font-weight: bold;
                ">√ó</button>
            `;
            
            debugReport.forEach(report => {
                const scoreMatch = report.currentScore === report.calculatedScore;
                const statusColor = scoreMatch ? '#4CAF50' : '#ff4444';
                
                html += `
                    <div style="background: #2a2a2a; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid ${statusColor};">
                        <h3 style="color: ${statusColor}; margin: 0 0 10px 0;">
                            ${report.userName} 
                            ${scoreMatch ? '‚úÖ' : '‚ö†Ô∏è MISMATCH'}
                        </h3>
                        <div style="display: flex; gap: 20px; margin-bottom: 10px;">
                            <span>Current Score: <strong>${report.currentScore}</strong></span>
                            <span>Calculated Score: <strong>${report.calculatedScore}</strong></span>
                            <span>Total Picks: <strong>${report.totalPicks}</strong></span>
                        </div>
                        <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                            <span style="color: #4CAF50;">‚úÖ Correct: ${report.correctPicks}</span>
                            <span style="color: #ff4444;">‚ùå Wrong: ${report.incorrectPicks}</span>
                            <span style="color: #888;">‚è≥ Pending: ${report.pendingPicks}</span>
                        </div>
                        <button onclick="manualUpdateScore('${report.userName}', ${report.calculatedScore})" 
                                style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                            Fix Score to ${report.calculatedScore}
                        </button>
                        <button onclick="showGameDetails('${report.entryId}')" 
                                style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">
                            View All Games
                        </button>
                    </div>
                `;
            });
            
            content.innerHTML = html;
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        // Manual score update function
        async function manualUpdateScore(userName, newScore) {
            console.log(`üîß Manually updating score for ${userName} to ${newScore}`);
            
            const entry = currentEntries.find(e => 
                (e.userName && e.userName === userName) || 
                (e.twitterHandle && e.twitterHandle === userName)
            );
            
            if (!entry) {
                alert(`Entry not found for ${userName}`);
                return;
            }
            
            try {
                console.log(`üìä Updating entry ${entry.id} score from ${entry.score} to ${newScore}`);
                
                // Method 1: Use backend's updateEntryScore if available
                if (backend && backend.updateEntryScore) {
                    console.log('üî• Using backend.updateEntryScore method...');
                    const response = await backend.updateEntryScore(entry.id, newScore);
                    console.log('üìä Firebase backend update response:', response);
                }
                
                // Method 2: Also try direct Firebase update as backup
                if (integration && integration.db) {
                    console.log('üî• Also updating via direct Firebase integration...');
                    const updateData = {
                        score: newScore,
                        lastScoreUpdate: new Date().toISOString(),
                        manuallyUpdated: true
                    };
                    
                    await integration.db.collection('contest_entries')
                        .doc(entry.id)
                        .update(updateData);
                    console.log('‚úÖ Direct Firebase update completed');
                }
                
                // Method 3: Enhanced backend update if available
                if (window.enhancedBackend && window.enhancedBackend.updateEntryScore) {
                    console.log('üöÄ Also updating via enhanced backend...');
                    await window.enhancedBackend.updateEntryScore(entry.id, newScore);
                    console.log('‚úÖ Enhanced backend update completed');
                }
                
                // Update locally in memory
                const oldScore = entry.score;
                entry.score = newScore;
                entry.lastScoreUpdate = new Date().toISOString();
                entry.manuallyUpdated = true;
                
                console.log(`üìä Local score update: ${oldScore} ‚Üí ${newScore} for ${userName}`);
                
                // Update in enhanced entry results if they exist
                const contestDate = document.getElementById('contest-date').value;
                if (window.enhancedEntryResults && window.enhancedEntryResults[contestDate] && window.enhancedEntryResults[contestDate][entry.id]) {
                    window.enhancedEntryResults[contestDate][entry.id].score = newScore;
                    window.enhancedEntryResults[contestDate][entry.id].manuallyUpdated = true;
                    console.log('üìä Updated enhanced entry results in session');
                }
                
                // Verify the update by checking the database
                console.log('üîç Verifying database update...');
                let verificationPassed = false;
                
                try {
                    // Wait a moment for database to update
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Reload entry from database to verify
                    const verifyEntries = await backend.getContestEntries(contestDate, currentContestType);
                    const verifyEntry = verifyEntries.find(e => e.id === entry.id);
                    
                    if (verifyEntry && verifyEntry.score === newScore) {
                        verificationPassed = true;
                        console.log('‚úÖ Database update verified successfully');
                    } else {
                        console.warn('‚ö†Ô∏è Database verification failed:', {
                            expected: newScore,
                            actual: verifyEntry?.score,
                            entryFound: !!verifyEntry
                        });
                    }
                } catch (verifyError) {
                    console.warn('‚ö†Ô∏è Could not verify database update:', verifyError);
                    // Don't fail the operation just because verification failed
                    verificationPassed = true;
                }
                
                // Refresh the display
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                } else {
                    updateEntriesTable(currentEntries);
                }
                
                // Show success message with verification status
                const verificationMsg = verificationPassed ? 
                    ' (Database update verified)' : 
                    ' (Update completed - verification pending)';
                
                alert(`‚úÖ Updated ${userName} score to ${newScore}${verificationMsg}`);
                console.log(`‚úÖ Successfully updated ${userName} score to ${newScore}`);
                
                return true; // Indicate success
                
            } catch (error) {
                console.error('‚ùå Failed to update score:', error);
                alert(`Failed to update score: ${error.message}`);
                return false; // Indicate failure
            }
        }
        
        // Show detailed game breakdown
        function showGameDetails(entryId) {
            const debugData = window.debugData;
            if (!debugData) {
                alert('No debug data available. Run the debugger first.');
                return;
            }
            
            const report = debugData.entryReports.find(r => r.entryId === entryId);
            if (!report) {
                alert('Entry not found in debug data.');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'game-details-modal';
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
                background: rgba(0,0,0,0.9); z-index: 10001; 
                overflow-y: auto; padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: #1a1a1a; border: 2px solid #ff6b00; 
                border-radius: 12px; padding: 30px; max-width: 1000px; 
                margin: 0 auto; color: white; position: relative;
            `;
            
            let html = `
                <h2 style="color: #ff6b00; margin-bottom: 20px;">üéÆ Game Details: ${report.userName}</h2>
                <button onclick="closeGameDetailsModal()" style="
                    position: absolute; top: 10px; right: 10px; 
                    background: #ff6b00; border: none; color: white; 
                    width: 30px; height: 30px; border-radius: 50%; cursor: pointer;
                    font-size: 18px; font-weight: bold;
                ">√ó</button>
                <div style="margin-bottom: 20px;">
                    <strong>Score: ${report.calculatedScore}/${report.totalPicks}</strong>
                </div>
            `;
            
            report.gameDetails.forEach((game, index) => {
                const statusColor = game.isCorrect === true ? '#4CAF50' : 
                                  game.isCorrect === false ? '#ff4444' : '#888';
                const statusIcon = game.isCorrect === true ? '‚úÖ' : 
                                 game.isCorrect === false ? '‚ùå' : '‚è≥';
                
                html += `
                    <div style="background: #2a2a2a; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 3px solid ${statusColor};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span><strong>Game ${index + 1}:</strong> ${game.originalGameId}</span>
                            <span style="color: ${statusColor};">${statusIcon} ${game.status}</span>
                        </div>
                        <div style="margin-top: 5px; font-size: 0.9em;">
                            <span>Pick: <strong>${game.pick}</strong></span>
                            ${game.result ? 
                                ` | Winner: <strong>${game.result.winner || 'Unknown'}</strong> | Score: ${game.result.score || 'N/A'}` : 
                                ' | No result available'
                            }
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        // Force recalculate all scores
        async function forceRecalculateAllScores() {
            if (!confirm('This will recalculate and update ALL player scores in the database. Continue?')) {
                return;
            }
            
            console.log('üöÄ FORCE RECALCULATING ALL SCORES');
            
            try {
                // Run the debugger to get calculations
                await manualScoreDebugger();
                
                // Wait a moment for debug data to be ready
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (!window.debugData) {
                    alert('Failed to generate debug data');
                    return;
                }
                
                const reports = window.debugData.entryReports;
                let updatedCount = 0;
                let failedCount = 0;
                
                console.log(`üìä Processing ${reports.length} player scores...`);
                
                for (const report of reports) {
                    if (report.currentScore !== report.calculatedScore) {
                        console.log(`üîß Updating ${report.userName}: ${report.currentScore} ‚Üí ${report.calculatedScore}`);
                        
                        const success = await manualUpdateScore(report.userName, report.calculatedScore);
                        if (success) {
                            updatedCount++;
                        } else {
                            failedCount++;
                        }
                        
                        // Small delay to avoid overwhelming Firebase
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } else {
                        console.log(`‚úÖ ${report.userName}: Score already correct (${report.currentScore})`);
                    }
                }
                
                // Final verification - reload data from database
                console.log('üîç Performing final verification by reloading from database...');
                await loadContestData();
                
                // Show results
                if (failedCount > 0) {
                    alert(`‚ö†Ô∏è Recalculation completed with issues:\n‚úÖ Updated: ${updatedCount} players\n‚ùå Failed: ${failedCount} players\n\nCheck console for details.`);
                } else {
                    alert(`‚úÖ Successfully updated ${updatedCount} player scores!\n\nAll scores have been saved to the database and will be used for contest resolution.`);
                }
                
                console.log(`üìä Recalculation summary: ${updatedCount} updated, ${failedCount} failed`);
                
            } catch (error) {
                console.error('‚ùå Failed to recalculate scores:', error);
                alert(`Failed to recalculate scores: ${error.message}`);
            }
        }
        
        // Verify database score integrity
        // NEW FUNCTION: Verify that manual score updates are preserved in database
        async function verifyManualScoresPersistence() {
            const contestDate = document.getElementById('contest-date').value;
            
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            try {
                console.log('üîç Verifying manual score persistence in database...');
                
                // Get fresh entries from database
                const freshEntries = await backend.getContestEntries(contestDate, currentContestType);
                
                // Check specifically for @squirrelxrp and @yroc710
                const squirrel = freshEntries.find(e => e.userName === '@squirrelxrp');
                const yroc = freshEntries.find(e => e.userName === '@yroc710');
                
                let verificationReport = 'üîç MANUAL SCORE VERIFICATION REPORT\n\n';
                verificationReport += 'Database scores for manually updated users:\n\n';
                
                if (squirrel) {
                    verificationReport += `@squirrelxrp: ${squirrel.score} ${squirrel.score === 10 ? '‚úÖ CORRECT' : '‚ùå INCORRECT (should be 10)'}\n`;
                } else {
                    verificationReport += '@squirrelxrp: NOT FOUND ‚ùå\n';
                }
                
                if (yroc) {
                    verificationReport += `@yroc710: ${yroc.score} ${yroc.score === 8 ? '‚úÖ CORRECT' : '‚ùå INCORRECT (should be 8)'}\n`;
                } else {
                    verificationReport += '@yroc710: NOT FOUND ‚ùå\n';
                }
                
                // Show all scores for comparison
                verificationReport += '\nAll current database scores:\n';
                freshEntries.forEach(entry => {
                    verificationReport += `${entry.userName}: ${entry.score}\n`;
                });
                
                alert(verificationReport);
                
                console.log('üìä Database verification complete:', {
                    squirrelScore: squirrel?.score,
                    yrocScore: yroc?.score,
                    allEntries: freshEntries.map(e => ({ userName: e.userName, score: e.score }))
                });
                
            } catch (error) {
                console.error('‚ùå Failed to verify manual scores:', error);
                alert('Failed to verify scores: ' + error.message);
            }
        }

        async function verifyDatabaseScores() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate || currentEntries.length === 0) {
                alert('Please load contest data first!');
                return;
            }
            
            console.log('üîç VERIFYING DATABASE SCORE INTEGRITY');
            
            try {
                // Reload fresh data from database
                const freshEntries = await backend.getContestEntries(contestDate, currentContestType);
                
                console.log('üìä Comparing current entries vs database entries...');
                
                let mismatches = [];
                
                currentEntries.forEach(localEntry => {
                    const dbEntry = freshEntries.find(e => e.id === localEntry.id);
                    
                    if (!dbEntry) {
                        mismatches.push({
                            player: localEntry.userName || localEntry.twitterHandle,
                            issue: 'Entry not found in database',
                            localScore: localEntry.score,
                            dbScore: 'N/A'
                        });
                    } else if (localEntry.score !== dbEntry.score) {
                        mismatches.push({
                            player: localEntry.userName || localEntry.twitterHandle,
                            issue: 'Score mismatch',
                            localScore: localEntry.score,
                            dbScore: dbEntry.score
                        });
                    }
                });
                
                if (mismatches.length === 0) {
                    alert('‚úÖ Database verification passed!\n\nAll local scores match the database. Contest resolution will use the correct scores.');
                    console.log('‚úÖ All scores verified - database is in sync');
                } else {
                    console.warn('‚ö†Ô∏è Score mismatches found:', mismatches);
                    
                    let message = `‚ö†Ô∏è Found ${mismatches.length} score mismatches:\n\n`;
                    mismatches.forEach(mismatch => {
                        message += `‚Ä¢ ${mismatch.player}: Local=${mismatch.localScore}, DB=${mismatch.dbScore} (${mismatch.issue})\n`;
                    });
                    message += '\nRecommend running "Force Recalculate All" to fix these issues.';
                    
                    alert(message);
                }
                
                return mismatches.length === 0;
                
            } catch (error) {
                console.error('‚ùå Database verification failed:', error);
                alert(`Database verification failed: ${error.message}`);
                return false;
            }
        }
        
        // Make these functions globally available
        window.manualScoreDebugger = manualScoreDebugger;
        window.manualUpdateScore = manualUpdateScore;
        window.showGameDetails = showGameDetails;
        window.forceRecalculateAllScores = forceRecalculateAllScores;
        window.verifyDatabaseScores = verifyDatabaseScores;
        
        // Modal close functions
        function closeDebugModal() {
            const modal = document.getElementById('debug-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        function closeGameDetailsModal() {
            const modal = document.getElementById('game-details-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Make close functions globally available
        window.closeDebugModal = closeDebugModal;
        window.closeGameDetailsModal = closeGameDetailsModal;
    
    </script>
</body>
</html>