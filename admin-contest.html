<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contest Admin - $NUTS Sports Pick'em</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="src/assets/images/nuts-logo.jpg">
    
    <!-- Styles -->
    <link rel="stylesheet" href="src/css/styles.css">
    <link rel="stylesheet" href="src/css/enhanced-contest.css">
    
    <style>
        .admin-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }
        
        .entries-table {
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
        }
        
        .entries-table table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .entries-table th {
            background: #2a2a2a;
            padding: 15px;
            text-align: left;
            color: #ffa500;
            font-weight: 600;
            border-bottom: 2px solid #444;
        }
        
        .entries-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
        }
        
        .entries-table tr:hover {
            background: #252525;
        }
        
        .picks-preview {
            font-size: 0.85em;
            color: #888;
        }
        
        .score-badge {
            background: #4CAF50;
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .date-selector {
            background: #2a2a2a;
            border: 1px solid #444;
            color: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .refresh-btn {
            background: #4CAF50;
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .refresh-btn:hover {
            background: #45a049;
        }
        
        .contest-tab {
            background: #2a2a2a;
            border: 2px solid #444;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .contest-tab:hover {
            border-color: #ffa500;
            background: #333;
        }
        
        .contest-tab.active-tab {
            background: #ffa500;
            color: #000;
            border-color: #ffa500;
        }
        
        .contest-controls {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Password Protection Modal -->
    <div id="password-modal" style="
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.95);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    ">
        <div style="
            background: #1a1a1a;
            border: 2px solid #ff6b00;
            border-radius: 12px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
        ">
            <img src="src/assets/images/nuts-logo.jpg" alt="$NUTS Logo" style="width: 60px; height: 60px; border-radius: 50%; margin-bottom: 20px;">
            <h2 style="color: #ff6b00; margin-bottom: 10px;">Admin Access Required</h2>
            <p style="color: #ccc; margin-bottom: 20px;">Please enter the admin password to continue</p>
            
            <input type="password" id="admin-password" placeholder="Enter password" style="
                background: #2a2a2a;
                border: 1px solid #444;
                color: white;
                padding: 12px 15px;
                border-radius: 8px;
                width: 100%;
                margin-bottom: 15px;
                font-size: 16px;
            " onkeypress="if(event.key === 'Enter') checkPassword()">
            
            <button onclick="checkPassword()" style="
                background: #ff6b00;
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                width: 100%;
            ">Enter Admin Area</button>
            
            <p id="password-error" style="color: #ff4444; margin-top: 15px; display: none;">
                Incorrect password. Please try again.
            </p>
        </div>
    </div>

    <script>
        // Check if already authenticated
        const isAuthenticated = sessionStorage.getItem('adminAuthenticated') === 'true';
        if (isAuthenticated) {
            document.getElementById('password-modal').style.display = 'none';
        }

        function checkPassword() {
            const password = document.getElementById('admin-password').value;
            const correctPassword = 'NutS420!!';
            
            if (password === correctPassword) {
                // Store authentication in session
                sessionStorage.setItem('adminAuthenticated', 'true');
                document.getElementById('password-modal').style.display = 'none';
            } else {
                // Show error
                document.getElementById('password-error').style.display = 'block';
                document.getElementById('admin-password').value = '';
                
                // Hide error after 3 seconds
                setTimeout(() => {
                    document.getElementById('password-error').style.display = 'none';
                }, 3000);
            }
        }

        // Focus on password input
        window.addEventListener('load', () => {
            if (!isAuthenticated) {
                document.getElementById('admin-password').focus();
            }
        });
    </script>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <img src="src/assets/images/nuts-logo.jpg" alt="$NUTS Logo" class="logo" style="width: 40px; height: 40px; border-radius: 50%;">
                <span class="brand-text">$NUTS Admin</span>
            </div>
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="mlb-contest.html" class="nav-link">MLB Contest</a>
                <a href="nfl-contest.html" class="nav-link">NFL Contest</a>
                <a href="admin-contest.html" class="nav-link active">Contest Admin</a>
            </div>
        </div>
    </nav>

    <main class="admin-container">
        <h1 style="color: #ffa500; margin-bottom: 30px;">Contest Administration</h1>
        
        <!-- Contest Type Tabs -->
        <div style="margin-bottom: 30px;">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button onclick="switchContestType('mlb')" id="mlb-tab" class="contest-tab active-tab">
                    ‚öæ MLB Contest
                </button>
                <button onclick="switchContestType('nfl')" id="nfl-tab" class="contest-tab">
                    üèà NFL Weekly Contest
                </button>
            </div>
        </div>
        
        <!-- MLB Contest Controls -->
        <div id="mlb-controls" class="contest-controls">
            <div style="margin-bottom: 30px;">
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                    <label style="color: #ffa500; font-weight: bold;">Contest Date:</label>
                    <input type="date" id="contest-date" class="date-selector">
                    <button onclick="loadContestData()" class="refresh-btn" style="background: #4CAF50;">üìã Load Data</button>
                </div>
                
                <!-- Simplified Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 15px; padding: 15px; background: #2a2a2a; border-radius: 8px;">
                    <button onclick="calculateAndUpdateScores()" class="refresh-btn" style="background: #FF9800; flex: 2;">
                        üßÆ Calculate Scores & Update Table
                    </button>
                    <button onclick="resolveContestWithWinners()" class="refresh-btn" style="background: #4CAF50; flex: 2;">
                        üèÜ Determine Winners & Complete Contest
                    </button>
                    <button onclick="toggleAdvancedControls()" class="refresh-btn" style="background: #666; flex: 1;">
                        ‚öôÔ∏è More
                    </button>
                </div>
                
                <!-- Advanced Controls (Collapsible) -->
                <div id="advanced-controls" style="display: none; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 15px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;">
                        <button onclick="debugScoring()" class="refresh-btn" style="background: #9C27B0; font-size: 0.85em;">üîç Debug</button>
                        <button onclick="fetchRealGameResults()" class="refresh-btn" style="background: #2196F3; font-size: 0.85em;">üîÑ Get Games</button>
                        <button onclick="clearSelectedDateData()" class="refresh-btn" style="background: #ff4444; font-size: 0.85em;">‚ùå Clear Date</button>
                    </div>
                </div>
            </div>
            
            <!-- Game Progress Display -->
            <div id="game-progress" style="background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 15px; margin-bottom: 20px; display: none;">
                <h3 style="color: #ffa500; margin: 0 0 10px 0;">üìä Live Game Status</h3>
                <div id="game-progress-content">
                    <p style="color: #888; margin: 0;">Click "Update Game Results" to see live game status</p>
                </div>
            </div>
        </div>
        
        <!-- NFL Contest Controls -->
        <div id="nfl-controls" class="contest-controls" style="display: none;">
            <div style="margin-bottom: 30px;">
                <label style="margin-right: 10px;">NFL Week:</label>
                <select id="nfl-week-selector" class="date-selector" style="width: auto; margin-right: 10px;">
                    <option value="1">Week 1</option>
                    <option value="2">Week 2</option>
                    <option value="3">Week 3</option>
                    <option value="4">Week 4</option>
                    <option value="5">Week 5</option>
                    <option value="6">Week 6</option>
                    <option value="7">Week 7</option>
                    <option value="8">Week 8</option>
                    <option value="9">Week 9</option>
                    <option value="10">Week 10</option>
                    <option value="11">Week 11</option>
                    <option value="12">Week 12</option>
                    <option value="13">Week 13</option>
                    <option value="14">Week 14</option>
                    <option value="15">Week 15</option>
                    <option value="16">Week 16</option>
                    <option value="17">Week 17</option>
                    <option value="18">Week 18</option>
                </select>
                <button onclick="loadNFLContestData()" class="refresh-btn">Load Data</button>
                <button onclick="debugNFLStorage()" class="refresh-btn" style="background: #2196F3; margin-left: 10px;">Debug Storage</button>
                <button onclick="clearNFLWeekData()" class="refresh-btn" style="background: #ff4444; margin-left: 10px;">Clear Week Data</button>
                <button onclick="clearAllNFLData()" class="refresh-btn" style="background: #ff6600; margin-left: 5px;">Clear All NFL</button>
            </div>
        </div>
        
        <!-- Statistics -->
        <div class="stats-grid" id="stats-grid">
            <div class="stat-card">
                <h3>Total Entries</h3>
                <div class="stat-value" id="total-entries">0</div>
            </div>
            <div class="stat-card">
                <h3>Prize Pool</h3>
                <div class="stat-value" id="prize-pool">0 NUTS</div>
            </div>
            <div class="stat-card">
                <h3>Contest Status</h3>
                <div class="stat-value" id="contest-status">Pending</div>
            </div>
            <div class="stat-card">
                <h3>Average Score</h3>
                <div class="stat-value" id="avg-score">0</div>
            </div>
        </div>
        
        <!-- Auto-Update Status -->
        <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
            <span style="color: #4CAF50;">üîÑ Auto-Update:</span>
            <span id="auto-update-status" style="color: #ccc;">Checking for game results every 10 minutes...</span>
            <span id="last-update" style="color: #888; margin-left: 10px;"></span>
        </div>
        
        <!-- Contest Winners Display -->
        <div id="winners-display" style="background: #1a1a1a; border: 2px solid #4CAF50; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: none;">
            <h2 style="color: #4CAF50; text-align: center; margin: 0 0 20px 0;">üèÜ Contest Winners üèÜ</h2>
            <div id="winners-content">
                <!-- Winner details will be populated here -->
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideWinners()" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                    Hide Winners
                </button>
                <button onclick="exportWinners()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-left: 10px;">
                    üìã Export Winners List
                </button>
            </div>
        </div>
        
        <!-- Entries Table -->
        <div class="entries-table">
            <h2 style="padding: 20px; color: #ffa500;" id="entries-table-title">MLB Contest Entries</h2>
            <table>
                <thead>
                    <tr>
                        <th>Entry ID</th>
                        <th>User</th>
                        <th>X Handle</th>
                        <th>Wallet</th>
                        <th>Picks</th>
                        <th id="tiebreaker-header">Tiebreaker</th>
                        <th>Score</th>
                        <th>Prize</th>
                        <th>Status</th>
                        <th>Time</th>
                    </tr>
                </thead>
                <tbody id="entries-tbody">
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            Select a date and click Load Data
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <!-- Actions -->
        <div style="margin-top: 30px; text-align: center;">
            <button onclick="calculateWinners()" class="btn btn-primary" style="margin-right: 10px;">
                Calculate Winners
            </button>
            <button onclick="completeContest()" class="btn btn-primary" style="margin-right: 10px; background: #ff9900;">
                Complete Contest
            </button>
            <button onclick="exportData()" class="btn btn-secondary">
                Export to CSV
            </button>
        </div>
    </main>

    <!-- Payout Modal -->
    <div id="payout-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="background: #1a1a1a; border: 2px solid #ff6b00; border-radius: 12px; padding: 30px; margin: 50px auto; max-width: 600px; position: relative;">
            <button onclick="closePayoutModal()" style="position: absolute; top: 10px; right: 10px; background: #ff6b00; border: none; color: white; width: 30px; height: 30px; border-radius: 50%; cursor: pointer;">√ó</button>
            
            <h2 style="color: #ff6b00; margin-bottom: 20px;">Manual Payout Process</h2>
            
            <div style="background: #ff3333; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <strong>‚ö†Ô∏è IMPORTANT: All payouts must be sent manually through your Xaman wallet</strong>
            </div>
            
            <div id="payout-details" style="margin-bottom: 20px;">
                <!-- Details will be populated dynamically -->
            </div>
            
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button onclick="showManualPayment()" style="flex: 1; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    üìã Show Manual Payment Info
                </button>
                <button onclick="generatePayoutQR()" style="flex: 1; background: #ff6b00; color: white; border: none; padding: 15px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                    üì± Generate QR Code
                </button>
            </div>
            
            <div id="payment-method-content" style="margin-top: 20px;">
                <!-- Payment method content will appear here -->
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
    <script src="config/config-browser.js"></script>
    <script src="config/environment.js"></script>
    <script src="src/js/firebase-integration.js"></script>
    <script src="src/js/firebase-xaman-integration.js"></script>
    <script src="src/js/contest-backend.js"></script>
    <script src="src/js/contest-backend-production.js"></script>
    <script src="src/js/contest-backend-enhanced.js"></script>
    <script src="src/js/enhanced-display.js"></script>
    <script src="src/js/mlb-schedule-free.js"></script>
    <script src="src/js/contest-integration-enhanced.js"></script>
    
    <script>
        let integration;
        let backend;
        let currentEntries = [];
        let currentContestType = 'mlb'; // 'mlb' or 'nfl'
        let currentNFLWeek = 1;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Set today's date as default in EST
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const todayString = `${year}-${month}-${day}`;
            
            document.getElementById('contest-date').value = todayString;
            console.log('üìÖ Set default date to:', todayString);
            
            // Initialize Firebase integration first
            console.log('üî• Setting up Firebase integration...');
            
            // Wait for firebaseIntegration to be available (it might be created by firebase-integration.js)
            let retries = 0;
            const maxRetries = 50;
            
            while (!window.firebaseIntegration && retries < maxRetries) {
                console.log('‚è≥ Waiting for Firebase Integration to load...');
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }
            
            // If not available, create it
            if (!window.firebaseIntegration) {
                console.log('üîß Creating Firebase Integration instance...');
                window.firebaseIntegration = new FirebaseIntegration();
            }
            
            console.log('üîÑ Starting Firebase initialization...');
            await window.firebaseIntegration.initialize();
            
            // Initialize Firebase + Xaman integration
            integration = new FirebaseXamanIntegration();
            await integration.init();
            
            // Always use production Firebase backend - NO LOCAL STORAGE
            console.log('üåê Using production Firebase backend ONLY - no local storage allowed');
            
            // Force production backend only
            if (window.ContestBackendProduction) {
                backend = new ContestBackendProduction();
                await backend.init();
                console.log('‚úÖ Production Firebase backend initialized');
                
                // Store reference for global access
                window.backend = backend;
                window.contestBackendProduction = backend;
            } else {
                console.error('‚ùå Production backend not available!');
                alert('Error: Production Firebase backend not available. Please refresh the page.');
                return;
            }
            
            // Verify we have a production Firebase backend
            if (!backend || backend.constructor.name !== 'ContestBackendProduction') {
                console.error('‚ùå Only production Firebase backend allowed!');
                alert('Error: Production Firebase backend required. Please refresh the page.');
                return;
            }
            
            // Load today's data
            loadContestData();
            
            // Set up automatic score updates every 10 minutes
            console.log('‚è∞ Setting up automatic score updates...');
            setInterval(async () => {
                const contestDate = document.getElementById('contest-date').value;
                if (contestDate && currentEntries.length > 0) {
                    console.log('üîÑ Automatic score update check...');
                    
                    // Update status
                    const statusElement = document.getElementById('auto-update-status');
                    if (statusElement) {
                        statusElement.textContent = 'Checking for updates...';
                        statusElement.style.color = '#ff9900';
                    }
                    
                    try {
                        const gameResults = await fetchRealGameResults(contestDate, false); // false = no alert
                        if (Object.keys(gameResults).length > 0) {
                            await updateEntryScores(gameResults);
                            updateStats({ totalEntries: currentEntries.length, prizePool: currentEntries.length * 50, avgScore: 0 });
                            
                            // Use enhanced display if available
                            if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                                window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                            } else {
                                updateEntriesTable(currentEntries);
                            }
                            
                            console.log('‚úÖ Automatic score update completed');
                            
                            if (statusElement) {
                                statusElement.textContent = 'Scores updated with live results!';
                                statusElement.style.color = '#4CAF50';
                            }
                        } else {
                            if (statusElement) {
                                statusElement.textContent = 'No completed games yet...';
                                statusElement.style.color = '#888';
                            }
                        }
                        
                        // Update last check time
                        const lastUpdateElement = document.getElementById('last-update');
                        if (lastUpdateElement) {
                            lastUpdateElement.textContent = `Last checked: ${new Date().toLocaleTimeString()}`;
                        }
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Automatic score update failed:', error);
                        if (statusElement) {
                            statusElement.textContent = 'Update failed - will retry...';
                            statusElement.style.color = '#ff4444';
                        }
                    }
                }
            }, 10 * 60 * 1000); // Every 10 minutes
        });
        
        async function loadContestData() {
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a date');
                return;
            }
            
            // Force production Firebase backend only
            if (!backend || backend.constructor.name !== 'ContestBackendProduction') {
                console.error('‚ùå Production Firebase backend required!');
                alert('Error: Production Firebase backend required. Please refresh the page.');
                return;
            }
            
            // Verify backend is ready and is production
            console.log('‚úÖ Using production Firebase backend:', backend.constructor.name);
            
            try {
                console.log('üîÑ Loading data for', contestDate);
                console.log('üîÑ Firebase enabled:', integration?.firebase?.initialized);
                console.log('üîÑ Production backend ready:', backend?.constructor?.name === 'ContestBackendProduction');
                
                // Get entries from production Firebase backend ONLY
                console.log('ÔøΩ Using production Firebase backend to get entries...');
                
                // Use production Firebase backend only
                console.log('üîß Production Firebase backend confirmed:', backend.constructor.name);
                
                // Try with sport filter first, then without if no results (for backward compatibility)
                currentEntries = await backend.getContestEntries(contestDate, currentContestType);
                
                // If no results with sport filter, try without filter for MLB (backward compatibility)
                if (currentEntries.length === 0 && currentContestType === 'mlb') {
                    console.log('üîÑ No entries found with sport filter, trying without filter for backward compatibility...');
                    currentEntries = await backend.getContestEntries(contestDate);
                }
                
                console.log('üìä Final loaded entries:', currentEntries.length, currentEntries.length > 0 ? currentEntries[0] : 'none');
                
                // Debug: Log entry structure for first entry
                if (currentEntries.length > 0) {
                    console.log('üîç First entry structure:', {
                        id: currentEntries[0].id,
                        userName: currentEntries[0].userName,
                        score: currentEntries[0].score,
                        tiebreakerRuns: currentEntries[0].tiebreakerRuns,
                        picks: currentEntries[0].picks,
                        totalPicksCount: currentEntries[0].picks ? Object.keys(currentEntries[0].picks).length : 0,
                        sampleGameIds: currentEntries[0].picks ? Object.keys(currentEntries[0].picks).slice(0, 3) : []
                    });
                    
                    // Show tiebreaker info for all entries
                    console.log('üèÉ Tiebreaker values for all entries:');
                    currentEntries.forEach((entry, index) => {
                        console.log(`  ${index + 1}. ${entry.userName}: ${entry.tiebreakerRuns || 'No tiebreaker'} runs`);
                    });
                }
                
                // Get stats - use backend if available, otherwise integration
                let stats;
                if (backend.getContestStats) {
                    stats = await backend.getContestStats(currentContestType, contestDate);
                } else {
                    stats = await integration.getContestStats(contestDate);
                }
                
                // Update UI
                updateStats(stats);
                
                // Enrich entries with team details if enhanced backend is available
                let enrichedEntries = currentEntries;
                if (window.contestBackendEnhanced) {
                    try {
                        console.log('üöÄ Enriching entries with team details...');
                        enrichedEntries = await Promise.all(currentEntries.map(async (entry) => {
                            if (entry.picks && !entry.gamesDetailed) {
                                try {
                                    const enrichedGames = await window.contestBackendEnhanced.enrichPicksWithGameDetails(entry.picks, contestDate);
                                    return {
                                        ...entry,
                                        gamesDetailed: enrichedGames
                                    };
                                } catch (enrichError) {
                                    console.warn('‚ö†Ô∏è Failed to enrich entry:', entry.id, enrichError);
                                    return entry;
                                }
                            }
                            return entry;
                        }));
                        console.log('‚úÖ Entries enriched with team details');
                        
                        // Update the current entries with enriched data
                        currentEntries = enrichedEntries;
                    } catch (enrichError) {
                        console.warn('‚ö†Ô∏è Failed to enrich entries, using original data:', enrichError);
                        enrichedEntries = currentEntries;
                    }
                }
                
                // Use enhanced display if available, otherwise fall back to standard
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    console.log('üåü Using enhanced admin display function');
                    window.enhancedDisplay.displayAdminEntries(enrichedEntries, contestDate);
                } else {
                    console.log('üìä Using standard admin display function');
                    updateEntriesTable(enrichedEntries);
                }
                
            } catch (error) {
                console.error('Failed to load data:', error);
                alert('Failed to load contest data: ' + error.message);
            }
        }
        
        // Contest type switching functions
        function switchContestType(type) {
            currentContestType = type;
            
            // Update tab appearance
            document.querySelectorAll('.contest-tab').forEach(tab => {
                tab.classList.remove('active-tab');
            });
            document.getElementById(`${type}-tab`).classList.add('active-tab');
            
            // Show/hide controls
            document.getElementById('mlb-controls').style.display = type === 'mlb' ? 'block' : 'none';
            document.getElementById('nfl-controls').style.display = type === 'nfl' ? 'block' : 'none';
            
            // Update table title and headers
            let tableTitle = '';
            let tiebreakerHeader = '';
            
            if (type === 'mlb') {
                tableTitle = 'MLB Contest Entries';
                tiebreakerHeader = 'Tiebreaker';
            } else if (type === 'nfl') {
                tableTitle = 'NFL Contest Entries';
                tiebreakerHeader = 'Tiebreaker Points';
            }
            
            document.getElementById('entries-table-title').textContent = tableTitle;
            document.getElementById('tiebreaker-header').textContent = tiebreakerHeader;
            
            // Update stats grid headers for context
            const statCards = document.querySelectorAll('.stat-card h3');
            if (type === 'nfl') {
                statCards[0].textContent = 'Week Entries';
                statCards[1].textContent = 'Week Pool';
                statCards[2].textContent = 'Week Status';
                statCards[3].textContent = 'Avg Score';
            } else {
                statCards[0].textContent = 'Total Entries';
                statCards[1].textContent = 'Prize Pool';
                statCards[2].textContent = 'Contest Status';
                statCards[3].textContent = 'Average Score';
            }
            
            // Clear current data
            currentEntries = [];
            document.getElementById('entries-tbody').innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; color: #888;">
                        ${type === 'mlb' ? 'Select a date and click Load Data' : 'Select a week and click Load Data'}
                    </td>
                </tr>
            `;
            
            // Reset stats
            updateStats({ totalEntries: 0, prizePool: 0, avgScore: 0 });
        }
        
        // NFL-specific functions
        async function loadNFLContestData() {
            const weekSelector = document.getElementById('nfl-week-selector');
            const selectedWeek = parseInt(weekSelector.value);
            currentNFLWeek = selectedWeek;
            
            try {
                console.log('üèà Loading NFL data for week', selectedWeek);
                
                // Get NFL entries using production Firebase backend ONLY
                console.log('üìä Using production Firebase backend for NFL entries...', backend.constructor.name);
                
                // Calculate the week date for the backend call
                const seasonStart = new Date(2025, 8, 7); // September 7, 2025
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((selectedWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                // Get NFL entries from Firebase backend only
                let nflEntries = [];
                try {
                    nflEntries = await backend.getContestEntries(weekDateString, 'nfl', selectedWeek);
                    console.log('üìä Got NFL entries from Firebase backend:', nflEntries.length);
                } catch (error) {
                    console.error('Failed to get NFL entries from Firebase backend:', error);
                    nflEntries = [];
                }
                
                currentEntries = nflEntries;
                console.log('üìä Final NFL entries loaded:', currentEntries.length);
                
                // Calculate stats
                let stats;
                if (backend.getContestStats) {
                    try {
                        stats = await backend.getContestStats('nfl', weekDateString, selectedWeek);
                    } catch (error) {
                        console.warn('Failed to get stats from backend, calculating locally:', error);
                        stats = calculateNFLStats(currentEntries);
                    }
                } else {
                    stats = calculateNFLStats(currentEntries);
                }
                
                // Update UI
                updateStats(stats);
                updateNFLEntriesTable(currentEntries);
                
            } catch (error) {
                console.error('Failed to load NFL data:', error);
                alert('Failed to load NFL contest data: ' + error.message);
            }
        }
        
        function calculateNFLStats(entries) {
            const totalEntries = entries.length;
            const prizePool = totalEntries * 50; // 50 NUTS per entry
            const avgScore = entries.length > 0 ? 
                entries.reduce((sum, entry) => sum + (entry.score || 0), 0) / entries.length : 0;
            
            return { totalEntries, prizePool, avgScore };
        }
        
        function updateNFLEntriesTable(entries) {
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for NFL Week ${currentNFLWeek}
                        </td>
                    </tr>
                `;
                return;
            }
            
            tbody.innerHTML = entries.map(entry => `
                <tr>
                    <td style="font-family: monospace; font-size: 0.85em;">
                        ${entry.id ? entry.id.substring(0, 12) + '...' : 'NFL_' + Date.now()}
                    </td>
                    <td>${entry.userName || entry.name || 'Anonymous'}</td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview">
                        ${Object.keys(entry.picks || {}).length} picks
                    </td>
                    <td>${entry.tiebreakerPoints || 0} points</td>
                    <td>
                        ${entry.score !== undefined ? 
                            `<span class="score-badge">${entry.score}</span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td>${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${entry.timestamp ? new Date(entry.timestamp).toLocaleString() : 'N/A'}
                    </td>
                </tr>
            `).join('');
        }
        
        // NFL data clearing functions
        function clearNFLWeekData() {
            if (!confirm(`Clear all data for NFL Week ${currentNFLWeek}?`)) return;
            
            const keysToRemove = [
                `nfl_contest_entries_week_${currentNFLWeek}`,
                `nfl_entries_week_${currentNFLWeek}`,
                `contest_entries_nfl_week_${currentNFLWeek}`
            ];
            
            keysToRemove.forEach(key => localStorage.removeItem(key));
            alert(`Cleared NFL Week ${currentNFLWeek} data`);
            loadNFLContestData();
        }
        
        function clearAllNFLData() {
            if (!confirm('Clear ALL NFL contest data? This cannot be undone!')) return;
            
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (key && key.includes('nfl')) {
                    localStorage.removeItem(key);
                }
            }
            
            alert('Cleared all NFL contest data');
            loadNFLContestData();
        }
        
        function debugNFLStorage() {
            console.log('üîç Debug: Production Firebase Backend Status');
            console.log('üîß Backend type:', backend?.constructor?.name || 'Not available');
            console.log('üîß Backend ready:', backend ? 'Yes' : 'No');
            
            // Test backend connection
            if (backend && typeof backend.getContestStats === 'function') {
                console.log('‚úÖ Backend connection test: Functional');
                
                // Try to get current NFL week stats
                const seasonStart = new Date(2025, 8, 7); // September 7, 2025
                const weekStart = new Date(seasonStart);
                weekStart.setDate(weekStart.getDate() + ((currentNFLWeek - 1) * 7));
                const weekDateString = weekStart.toISOString().split('T')[0];
                
                backend.getContestStats('nfl', weekDateString, currentNFLWeek)
                    .then(stats => {
                        console.log(`üìä NFL Week ${currentNFLWeek} stats from Firebase:`, stats);
                    })
                    .catch(error => {
                        console.error('‚ùå Failed to get NFL stats from Firebase:', error);
                    });
            } else {
                console.log('‚ùå Backend connection test: Failed');
            }
            
            alert('Production Firebase backend debug complete. Check console for details.');
        }
        
        function updateStats(stats) {
            console.log('üìä Updating stats with:', stats);
            
            // Handle both direct stats object and nested stats object
            const actualStats = stats.stats || stats;
            
            document.getElementById('total-entries').textContent = actualStats.totalEntries || 0;
            document.getElementById('prize-pool').textContent = (actualStats.prizePool || 0) + ' NUTS';
            document.getElementById('contest-status').textContent = 
                (actualStats.totalEntries || 0) >= 2 ? 'Active' : 'Needs ' + (2 - (actualStats.totalEntries || 0)) + ' more';
            
            // Handle avgScore safely
            const avgScore = actualStats.avgScore || actualStats.averageScore || 0;
            document.getElementById('avg-score').textContent = Number(avgScore).toFixed(1);
        }
        
        function updateEntriesTable(entries) {
            if (currentContestType === 'nfl') {
                updateNFLEntriesTable(entries);
                return;
            }
            
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for this date
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort entries by score (descending) for leaderboard effect
            const sortedEntries = [...entries].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            // Check if scores are calculated
            const hasScores = sortedEntries.some(entry => entry.score !== undefined);
            const contestDate = document.getElementById('contest-date').value;
            const hasLocalScores = contestDate && localStorage.getItem(`scores_${contestDate}`);
            
            tbody.innerHTML = sortedEntries.map((entry, index) => {
                // Create detailed picks display
                const picksHtml = formatPicksDisplay(entry.picks || {});
                
                // Determine rank styling
                const rank = index + 1;
                const rankStyle = rank === 1 ? 'color: #FFD700; font-weight: bold;' : // Gold
                                 rank === 2 ? 'color: #C0C0C0; font-weight: bold;' : // Silver  
                                 rank === 3 ? 'color: #CD7F32; font-weight: bold;' : // Bronze
                                 'color: #888;';
                
                // Score display with indicators
                let scoreDisplay = '';
                if (entry.score !== undefined) {
                    const scoreIndicator = hasLocalScores ? 'üíæ' : 'üîÑ';
                    scoreDisplay = `<span class="score-badge" style="font-size: 1.1em; ${rank <= 3 ? 'background: ' + (rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32') + '; color: #000;' : ''}">${entry.score} ${scoreIndicator}</span>`;
                } else {
                    scoreDisplay = '<span style="color: #666;">Not calculated</span>';
                }
                
                return `
                <tr style="${rank <= 3 && hasScores ? 'background: rgba(255, 215, 0, 0.05);' : ''}">
                    <td style="font-family: monospace; font-size: 0.85em;">
                        <span style="${rankStyle}">#${rank}</span><br>
                        ${entry.id.substring(0, 8)}...
                    </td>
                    <td>
                        <strong>${entry.userName}</strong>
                        ${rank <= 3 && hasScores ? `<br><small style="${rankStyle}">${rank === 1 ? 'üëë Leader' : rank === 2 ? 'ü•à 2nd Place' : 'ü•â 3rd Place'}</small>` : ''}
                    </td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview" style="max-width: 200px;">
                        ${picksHtml}
                    </td>
                    <td style="text-align: center;">
                        <strong>${entry.tiebreakerRuns || 0}</strong> runs
                    </td>
                    <td style="text-align: center;">
                        ${scoreDisplay}
                    </td>
                    <td style="text-align: center;">${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                        ${entry.status === 'won' && entry.prizeWon > 0 ? `
                            <div style="margin-top: 5px;">
                                <button onclick="showPayoutOptions('${entry.id}')" 
                                        class="btn btn-sm" 
                                        style="background: #ff6b00; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em;">
                                    Pay Winner
                                </button>
                            </div>
                        ` : ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${new Date(entry.timestamp || entry.paymentTimestamp).toLocaleTimeString()}
                    </td>
                </tr>
            `;
            }).join('');
            
            // Add status message about scores
            if (hasScores) {
                const statusMessage = hasLocalScores ? 
                    'üíæ Scores loaded from local backup' : 
                    'üîÑ Scores calculated and saved to database';
                    
                const statusRow = `
                    <tr style="background: rgba(76, 175, 80, 0.1);">
                        <td colspan="10" style="text-align: center; padding: 10px; color: #4CAF50; font-size: 0.9em;">
                            ${statusMessage}
                        </td>
                    </tr>
                `;
                tbody.innerHTML = statusRow + tbody.innerHTML;
            }
        }
        
        // NEW FUNCTION: Format picks for display
        function formatPicksDisplay(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<span style="color: #666;">No picks</span>';
            }
            
            let html = `<div style="font-size: 0.8em;">`;
            let pickCount = 0;
            const maxDisplayPicks = 4; // Show first 4 picks, then "..."
            
            Object.entries(picks).forEach(([gameId, pick]) => {
                if (pickCount < maxDisplayPicks) {
                    // Try to get team names from the game ID or use generic names
                    const teams = getTeamNamesFromGameId(gameId);
                    const pickedTeam = pick === 'home' ? teams.home : teams.away;
                    
                    html += `
                        <div style="margin: 2px 0; padding: 2px 4px; background: #2a2a2a; border-radius: 3px; display: flex; justify-content: space-between;">
                            <span style="color: #888; font-size: 0.7em;">${teams.away} @ ${teams.home}</span>
                            <span style="color: #ffa500; font-weight: bold;">${pickedTeam}</span>
                        </div>
                    `;
                }
                pickCount++;
            });
            
            if (pickCount > maxDisplayPicks) {
                html += `<div style="color: #666; font-size: 0.7em; text-align: center; margin-top: 4px;">...and ${pickCount - maxDisplayPicks} more</div>`;
            }
            
            html += `</div>`;
            return html;
        }
        
        // Helper function to extract team names from game ID
        function getTeamNamesFromGameId(gameId) {
            // Try to extract team names from the game ID
            // Game IDs often follow patterns like "2025-08-05-NYY-BOS" or similar
            if (gameId && gameId.includes('-')) {
                const parts = gameId.split('-');
                if (parts.length >= 4) {
                    return {
                        away: parts[parts.length - 2] || 'Away',
                        home: parts[parts.length - 1] || 'Home'
                    };
                }
            }
            
            // Fallback to generic names
            return {
                away: 'Away',
                home: 'Home'
            };
        }
        
        async function calculateWinners() {
            const minimumEntries = window.config?.contest?.minimumEntries || 4;
            
            if (currentEntries.length < minimumEntries) {
                const confirmRefund = confirm(
                    `Only ${currentEntries.length} entries (minimum ${minimumEntries} required).\n\n` +
                    `The contest will be cancelled and all entry fees will be refunded.\n\n` +
                    `Process refunds?`
                );
                
                if (confirmRefund) {
                    await processRefunds();
                }
                return;
            }
            
            // Get REAL game results instead of mock data
            const contestDate = document.getElementById('contest-date').value;
            let gameResults = {};
            
            try {
                console.log('üîÑ Fetching real game results for scoring...');
                gameResults = await fetchRealGameResults(contestDate, false); // false = don't show alerts
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate winners until games finish.');
                    return;
                }
                
                console.log('üìä Using real game results:', gameResults);
                
            } catch (error) {
                console.error('‚ùå Failed to get real game results:', error);
                alert('Failed to fetch real game results. Please try again.');
                return;
            }
            
            try {
                const result = await integration.updateGameResults(contestDate, gameResults);
                
                if (result) {
                    if (result.status === 'cancelled') {
                        alert(`Contest cancelled: ${result.reason}\nRefunds required for ${result.totalEntries} entries.`);
                        await processRefunds();
                    } else if (result.winners) {
                        // Show winners
                        let winnerMessage = 'üèÜ CONTEST RESULTS üèÜ\n\n';
                        winnerMessage += `Total Prize Pool: ${result.prizePool} NUTS\n\n`;
                        
                        result.winners.forEach(winner => {
                            const placeEmoji = winner.place === 1 ? 'ü•á' : winner.place === 2 ? 'ü•à' : 'ü•â';
                            winnerMessage += `${placeEmoji} ${winner.place === 1 ? '1st' : winner.place === 2 ? '2nd' : '3rd'} Place: ${winner.entry.userName}\n`;
                            winnerMessage += `   Score: ${winner.entry.score} correct picks\n`;
                            winnerMessage += `   Prize: ${winner.prize} NUTS\n\n`;
                        });
                        
                        winnerMessage += '\n\nüìã NOTE: All payouts are MANUAL\nClick OK to view payout details for each winner.';
                        
                        if (confirm(winnerMessage)) {
                            await processAllPayouts(result.winners);
                        }
                    }
                    
                    loadContestData(); // Reload to show updated data
                }
            } catch (error) {
                alert('Failed to calculate winners: ' + error.message);
            }
        }
        
        // NEW FUNCTION: Fetch real game results from MLB API
        async function fetchRealGameResults(contestDate = null, showAlert = true) {
            const dateToCheck = contestDate || document.getElementById('contest-date').value;
            
            if (!dateToCheck) {
                if (showAlert) alert('Please select a date first');
                return {};
            }
            
            try {
                console.log(`üîÑ Fetching real MLB game results for ${dateToCheck}...`);
                
                if (showAlert) {
                    document.body.style.cursor = 'wait';
                }
                
                // Initialize MLB Schedule API if not available
                if (!window.mlbSchedule) {
                    console.log('üì° Loading MLB Schedule API...');
                    const script = document.createElement('script');
                    script.src = 'src/js/mlb-schedule-free.js';
                    document.head.appendChild(script);
                    
                    // Wait for it to load
                    await new Promise(resolve => {
                        script.onload = resolve;
                        setTimeout(resolve, 2000); // fallback timeout
                    });
                }
                
                // Create date object properly to avoid timezone issues
                const dateParts = dateToCheck.split('-');
                const gameDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                
                console.log(`üóìÔ∏è Processing game results for: ${dateToCheck}`);
                console.log(`üóìÔ∏è Created date object: ${gameDate.toDateString()} (${gameDate.toISOString()})`);
                
                // Use the new getGameResults method that returns processed results
                const gameResults = await window.mlbSchedule.getGameResults(gameDate);
                
                // Always get games to show progress (regardless of completed games)
                const allGames = await window.mlbSchedule.getGamesForDate(gameDate);
                updateGameProgressDisplay(allGames);
                
                const completedGames = Object.keys(gameResults).filter(key => key !== 'lastGameRuns').length;
                
                console.log(`üìÖ Found ${completedGames} completed games for ${dateToCheck}`);
                
                if (completedGames === 0) {
                    if (showAlert) {
                        const games = await window.mlbSchedule.getGamesForDate(gameDate);
                        const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
                        const notStarted = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
                        
                        alert(`ÔøΩ Game Status Update for ${dateToCheck}:\n\n‚úÖ Completed: 0\nüîÑ In Progress: ${inProgress}\nüìÖ Not Started: ${notStarted}\n\nNo games have finished yet. Check back later!`);
                    }
                    return {};
                }
                
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    
                    alert(`üìä Game Results Updated!\n\n‚úÖ Completed Games: ${completedGames}\nüèÉ Total Runs: ${gameResults.lastGameRuns || 0}\n\nContest scores will be updated automatically.`);
                    
                    // Automatically recalculate scores for entries
                    await updateEntryScores(gameResults);
                    loadContestData(); // Refresh the display
                }
                
                return gameResults;
                
            } catch (error) {
                console.error('‚ùå Failed to fetch real game results:', error);
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    alert(`Failed to fetch game results: ${error.message}\n\nPlease check your internet connection and try again.`);
                }
                return {};
            }
        }
        
        async function processRefunds() {
            try {
                const contestDate = document.getElementById('contest-date').value;
                
                // Use the backend's refund method
                if (window.ContestBackend) {
                    const backend = new ContestBackend();
                    await backend.init();
                    
                    const result = await backend.processRefunds(contestDate);
                    
                    if (result.success) {
                        alert(
                            `‚úÖ Refunds Processed!\n\n` +
                            `Entries refunded: ${result.entriesRefunded}\n` +
                            `Total refund amount: ${result.totalRefundAmount} NUTS\n\n` +
                            `Please process the refunds manually through Xaman wallet.`
                        );
                    } else {
                        alert('Failed to process refunds: ' + result.error);
                    }
                } else {
                    alert('Contest backend not available');
                }
                
                loadContestData(); // Reload data
                
            } catch (error) {
                console.error('Failed to process refunds:', error);
                alert('Error processing refunds: ' + error.message);
            }
        }
        
        async function processAllPayouts(winners) {
            try {
                let successCount = 0;
                
                for (const winner of winners) {
                    const entry = winner.entry;
                    
                    if (!entry.walletAddress) {
                        alert(`‚ö†Ô∏è No wallet address for ${entry.userName}. Please process manually.`);
                        continue;
                    }
                    
                    // Show payout modal for each winner
                    showPayoutOptions(entry.id);
                    
                    // Wait for user to process this payout before continuing
                    await new Promise(resolve => {
                        const checkInterval = setInterval(() => {
                            if (!document.getElementById('payout-modal').style.display || 
                                document.getElementById('payout-modal').style.display === 'none') {
                                clearInterval(checkInterval);
                                resolve();
                            }
                        }, 1000);
                    });
                    
                    successCount++;
                }
                
                alert(`‚úÖ Processed ${successCount} payouts!`);
                
            } catch (error) {
                console.error('Failed to process payouts:', error);
                alert('Error processing payouts: ' + error.message);
            }
        }
        
        function exportData() {
            if (currentEntries.length === 0) {
                alert('No data to export');
                return;
            }
            
            // Create CSV
            const headers = ['Entry ID', 'User', 'X Handle', 'Wallet Address', 'Picks', 'Tiebreaker', 'Score', 'Prize', 'Status', 'Timestamp'];
            const rows = currentEntries.map(e => [
                e.id,
                e.userName,
                e.twitterHandle || '',
                e.walletAddress || '',
                Object.keys(e.picks || {}).length,
                e.tiebreakerRuns || 0,
                e.score || 0,
                e.prizeWon || 0,
                e.status || 'pending',
                new Date(e.timestamp || e.paymentTimestamp).toISOString()
            ]);
            
            const csv = [headers, ...rows].map(row => row.join(',')).join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `contest_entries_${document.getElementById('contest-date').value}.csv`;
            a.click();
        }
        
        // Payout functions
        let currentPayoutEntry = null;
        
        function showPayoutOptions(entryId) {
            const entry = currentEntries.find(e => e.id === entryId);
            if (!entry) return;
            
            currentPayoutEntry = entry;
            
            // Show modal
            document.getElementById('payout-modal').style.display = 'block';
            
            // Populate details
            document.getElementById('payout-details').innerHTML = `
                <div style="background: #2a2a2a; padding: 20px; border-radius: 8px;">
                    <h3 style="color: #4CAF50; margin-bottom: 15px;">Winner Details</h3>
                    <div style="display: grid; grid-template-columns: 150px 1fr; gap: 10px; color: #ccc;">
                        <div>Winner:</div>
                        <div style="color: white; font-weight: bold;">${entry.userName}</div>
                        
                        <div>Prize Amount:</div>
                        <div style="color: #ff6b00; font-weight: bold; font-size: 1.2em;">${entry.prizeWon} NUTS</div>
                        
                        <div>Contest Date:</div>
                        <div>${entry.contestDate}</div>
                        
                        <div>Correct Picks:</div>
                        <div>${entry.score} / ${entry.totalGames}</div>
                        
                        <div>Entry ID:</div>
                        <div style="font-family: monospace; font-size: 0.9em;">${entry.id}</div>
                    </div>
                </div>
            `;
            
            // Clear payment method content
            document.getElementById('payment-method-content').innerHTML = '';
        }
        
        function closePayoutModal() {
            document.getElementById('payout-modal').style.display = 'none';
            currentPayoutEntry = null;
        }
        
        function showManualPayment() {
            if (!currentPayoutEntry) return;
            
            // Get wallet address from entry
            const walletAddress = currentPayoutEntry.walletAddress || 'Not captured - check payment transaction';
            
            document.getElementById('payment-method-content').innerHTML = `
                <div style="background: #2a2a2a; padding: 20px; border-radius: 8px; border: 2px solid #4CAF50;">
                    <h3 style="color: #4CAF50; margin-bottom: 15px;">üìã Manual Payment Instructions</h3>
                    
                    <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <p style="color: #ff6b00; font-weight: bold; margin-bottom: 10px;">Step 1: Copy Payment Details</p>
                        <div style="color: #ccc; line-height: 1.8;">
                            <div style="margin-bottom: 10px;">
                                <strong>Recipient Wallet:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px; word-break: break-all; font-family: monospace;">
                                    ${walletAddress}
                                </div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>Amount:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px; font-size: 1.2em; color: #ff6b00;">
                                    ${currentPayoutEntry.prizeWon} NUTS
                                </div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <strong>Memo/Note:</strong>
                                <div style="background: #333; padding: 10px; border-radius: 4px; margin-top: 5px;">
                                    Contest Prize - ${currentPayoutEntry.contestDate}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #1a1a1a; padding: 15px; border-radius: 8px;">
                        <p style="color: #ff6b00; font-weight: bold; margin-bottom: 10px;">Step 2: Send Payment</p>
                        <ol style="color: #ccc; line-height: 1.8; margin: 0; padding-left: 20px;">
                            <li>Open your Xaman wallet</li>
                            <li>Tap "Send"</li>
                            <li>Enter the recipient wallet address</li>
                            <li>Select NUTS from your token list</li>
                            <li>Enter the prize amount</li>
                            <li>Add the memo for reference</li>
                            <li>Review and send</li>
                        </ol>
                    </div>
                    
                    <button onclick="markPayoutComplete()" style="width: 100%; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;">
                        ‚úÖ Mark Payout as Complete
                    </button>
                </div>
            `;
        }
        
        async function generatePayoutQR() {
            if (!currentPayoutEntry) return;
            
            // Check if wallet address is available
            if (!currentPayoutEntry.walletAddress) {
                document.getElementById('payment-method-content').innerHTML = `
                    <div style="background: #ff3333; color: white; padding: 20px; border-radius: 8px; text-align: center;">
                        <p><strong>Wallet address not available!</strong></p>
                        <p style="margin-top: 10px;">The winner's wallet address was not captured during entry.</p>
                        <p>Please use the manual payment option and check the transaction history.</p>
                    </div>
                `;
                return;
            }
            
            document.getElementById('payment-method-content').innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="spinner"></div>
                    <p style="color: #ccc; margin-top: 10px;">Generating payment QR code...</p>
                </div>
            `;
            
            try {
                // Call XUMM server to create payout payload
                const response = await fetch('http://localhost:3001/create-nuts-payment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        destination: currentPayoutEntry.walletAddress || null,
                        amount: currentPayoutEntry.prizeWon.toString(),
                        memo: `Contest Prize - ${currentPayoutEntry.contestDate}`
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.payload) {
                    document.getElementById('payment-method-content').innerHTML = `
                        <div style="background: #2a2a2a; padding: 20px; border-radius: 8px; border: 2px solid #ff6b00; text-align: center;">
                            <h3 style="color: #ff6b00; margin-bottom: 15px;">üì± Scan to Send Prize</h3>
                            
                            <div style="background: white; padding: 10px; border-radius: 8px; display: inline-block; margin-bottom: 15px;">
                                <img src="${data.payload.refs.qr_png}" width="250" height="250" alt="Payment QR">
                            </div>
                            
                            <div style="color: #ccc; margin-bottom: 15px;">
                                <p><strong>Amount:</strong> ${currentPayoutEntry.prizeWon} NUTS</p>
                                <p><strong>To:</strong> ${currentPayoutEntry.userName}</p>
                            </div>
                            
                            <p style="color: #888; font-size: 0.9em;">
                                Scan with Xaman wallet to send prize payment
                            </p>
                            
                            <button onclick="markPayoutComplete()" style="width: 100%; background: #4CAF50; color: white; border: none; padding: 15px; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;">
                                ‚úÖ Payment Sent - Mark Complete
                            </button>
                        </div>
                    `;
                    
                    // Start polling for payment status
                    pollPayoutStatus(data.payload.uuid);
                } else {
                    throw new Error(data.error || 'Failed to generate QR code');
                }
                
            } catch (error) {
                console.error('Failed to generate payout QR:', error);
                document.getElementById('payment-method-content').innerHTML = `
                    <div style="background: #ff3333; color: white; padding: 20px; border-radius: 8px; text-align: center;">
                        <p>Failed to generate QR code: ${error.message}</p>
                        <p style="margin-top: 10px;">Please use manual payment option.</p>
                    </div>
                `;
            }
        }
        
        async function pollPayoutStatus(uuid) {
            // Poll for payment completion
            let attempts = 0;
            const maxAttempts = 60;
            
            const checkStatus = async () => {
                if (attempts >= maxAttempts) return;
                
                try {
                    const response = await fetch(`http://localhost:3001/payload-status/${uuid}`);
                    const data = await response.json();
                    
                    if (data.meta?.signed === true) {
                        // Payment completed
                        alert('‚úÖ Payout sent successfully!');
                        await markPayoutComplete();
                        return;
                    }
                    
                    if (!data.meta?.resolved) {
                        attempts++;
                        setTimeout(checkStatus, 5000);
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                }
            };
            
            setTimeout(checkStatus, 3000);
        }
        
        function clearSelectedDateData() {
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a date first');
                return;
            }
            
            if (confirm(`Are you sure you want to clear all contest data for ${contestDate}?`)) {
                // Clear contest entries for this date
                const keys = [
                    `contest_entries_${contestDate}`,
                    `entries_${contestDate}`
                ];
                
                keys.forEach(key => {
                    if (localStorage.getItem(key)) {
                        console.log(`üóëÔ∏è Removing ${key}`);
                        localStorage.removeItem(key);
                    }
                });
                
                alert(`Cleared contest data for ${contestDate}`);
                loadContestData(); // Reload the page data
            }
        }
        
        function clearTestData() {
            console.log('üóëÔ∏è Clearing all test data...');
            
            // Clear all localStorage keys that might contain test data
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (
                    key.includes('contest_entries_') || 
                    key.includes('entries_') || 
                    key.includes('test_') ||
                    key.includes('mock_') ||
                    key.includes('demo_')
                )) {
                    keysToRemove.push(key);
                }
            }
            
            console.log('üóëÔ∏è Found test data keys:', keysToRemove);
            
            keysToRemove.forEach(key => {
                console.log(`üóëÔ∏è Removing ${key}`);
                localStorage.removeItem(key);
            });
            
            alert(`Cleared ${keysToRemove.length} test data keys. Click Load Data to refresh.`);
        }
        
        async function calculateAndSaveScores() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            try {
                console.log('üßÆ Calculating and saving scores...');
                
                // Fetch the latest game results
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('No game results available for this date. Please try again later.');
                    return;
                }
                
                // Calculate and save scores
                await updateEntryScores(gameResults);
                
                alert(`‚úÖ Scores calculated and saved successfully!\n\nCheck the leaderboard for updated scores.`);
                
            } catch (error) {
                console.error('‚ùå Failed to calculate and save scores:', error);
                alert(`Failed to calculate and save scores: ${error.message}`);
            }
        }
        
        async function resolveContestEnhanced() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            try {
                console.log(`üèÜ Starting enhanced contest resolution for ${contestDate}...`);
                
                // Call the enhanced contest resolution
                if (window.resolveContest) {
                    const result = await window.resolveContest(contestDate);
                    
                    if (result && result.winners) {
                        alert(`üèÜ Contest resolved successfully!\n\nWinners: ${result.winners.length}\nTotal Prize Pool: ${result.totalPrizePool || 0} NUTS\n\nCheck the updated entries table for details.`);
                        
                        // Display the winners in the UI
                        displayContestWinners(result.winners, contestDate, result.totalPrizePool || 0);
                        
                        // Reload the data to show updated results
                        await loadContestData();
                    } else {
                        alert('Contest resolution completed, but no result details available. Please check the console for more information.');
                    }
                } else {
                    throw new Error('Enhanced contest resolution function not available');
                }
                
            } catch (error) {
                console.error('‚ùå Failed to resolve contest:', error);
                alert(`Failed to resolve contest: ${error.message}\n\nPlease check the console for more details.`);
            }
        }
        
        async function debugScoring() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            console.log('üîç DEBUG SCORING - Starting detailed analysis...');
            console.log('üìÖ Contest Date:', contestDate);
            console.log('üìä Total Entries:', currentEntries.length);
            
            // Analyze entry structure
            currentEntries.forEach((entry, index) => {
                console.log(`\nüë§ Entry ${index + 1}: ${entry.userName}`);
                console.log('  üìã Picks:', entry.picks);
                console.log('  üèÜ Current Score:', entry.score);
                console.log('  üéØ Total Picks:', entry.picks ? Object.keys(entry.picks).length : 0);
                
                if (entry.picks) {
                    Object.entries(entry.picks).forEach(([gameId, pick]) => {
                        console.log(`    üéÆ Game ${gameId}: picked ${pick}`);
                    });
                }
            });
            
            // Try to fetch game results
            console.log('\nüîÑ Fetching game results...');
            try {
                const gameResults = await fetchRealGameResults(contestDate, false);
                console.log('üéÆ Game Results:', gameResults);
                console.log('üéÆ Game Result Keys:', Object.keys(gameResults));
                
                if (Object.keys(gameResults).length === 0) {
                    console.log('‚ùå No game results returned');
                    alert('No game results found for this date. This might be because:\n\n1. Games haven\'t been played yet\n2. Games are still in progress\n3. MLB API connection issue\n\nCheck the console for more details.');
                    return;
                }
                
                // Manually calculate scores for debugging
                console.log('\nüßÆ Manual Score Calculation:');
                currentEntries.forEach((entry, index) => {
                    if (!entry.picks) return;
                    
                    let calculatedScore = 0;
                    console.log(`\nüîç Processing ${entry.userName}:`);
                    
                    Object.entries(entry.picks).forEach(([gameId, pick]) => {
                        const gameResult = gameResults[gameId];
                        console.log(`  üéØ Game ${gameId}: picked ${pick}`);
                        
                        if (gameResult) {
                            console.log(`    üìä Result: ${gameResult.winner} won (${gameResult.status})`);
                            const isCorrect = pick === gameResult.winner;
                            if (isCorrect) {
                                calculatedScore++;
                                console.log(`    ‚úÖ CORRECT!`);
                            } else {
                                console.log(`    ‚ùå Wrong`);
                            }
                        } else {
                            console.log(`    ‚ùì No result found for this game ID`);
                        }
                    });
                    
                    console.log(`  üìä Calculated Score: ${calculatedScore}`);
                });
                
                console.log('\n‚úÖ Debug analysis complete - check console for detailed breakdown');
                alert('Debug analysis complete! Check the browser console (F12) for detailed scoring breakdown.');
                
            } catch (error) {
                console.error('‚ùå Debug error:', error);
                alert('Debug failed: ' + error.message);
            }
        }
        
        async function saveScoresToDatabase() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }
            
            if (!confirm(`Save current scores for ${currentEntries.length} entries to Firebase database?\n\nThis will update the leaderboard permanently.`)) {
                return;
            }
            
            try {
                console.log('üíæ Manual save to database initiated...');
                
                // Get real game results first
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    if (!confirm('No completed games found. Save current scores anyway?')) {
                        return;
                    }
                }
                
                // Use production backend to update scores via cloud function
                console.log('üíæ Updating scores via production backend...');
                
                let successCount = 0;
                let errorCount = 0;
                
                for (const entry of currentEntries) {
                    if (!entry.picks) continue;
                    
                    // Calculate score for this entry
                    let newScore = 0;
                    Object.entries(entry.picks).forEach(([gameId, pick]) => {
                        const gameResult = gameResults[gameId];
                        if (gameResult && pick === gameResult.winner) {
                            newScore++;
                        }
                    });
                    
                    try {
                        // Use the same backend base URL that's working for reads
                        const response = await fetch(`${backend.baseUrl}/updateEntryScore`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                entryId: entry.id,
                                score: newScore,
                                contestDate: contestDate
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            if (result.success) {
                                console.log(`üíæ Updated ${entry.userName}: ${newScore} points`);
                                entry.score = newScore; // Update local entry
                                successCount++;
                            } else {
                                console.error(`‚ùå Backend error for ${entry.userName}:`, result.error);
                                errorCount++;
                            }
                        } else {
                            console.error(`‚ùå HTTP ${response.status} for ${entry.userName}`);
                            errorCount++;
                        }
                    } catch (error) {
                        console.error(`‚ùå Request failed for ${entry.userName}:`, error);
                        errorCount++;
                    }
                }
                
                // Reload the contest data to show updated scores
                await loadContestData();
                
                if (successCount > 0) {
                    alert(`‚úÖ Scores saved successfully!\n\nUpdated: ${successCount}\nFailed: ${errorCount}\n\nThe contest leaderboard should now show the correct scores.`);
                } else {
                    alert(`‚ùå Failed to save any scores.\n\nPlease check that the backend updateEntryScore function is available.`);
                }
                
            } catch (error) {
                console.error('‚ùå Failed to save scores:', error);
                alert(`Failed to save scores to database: ${error.message}\n\nPlease check the console for more details.`);
            }
        }
        
        function clearAllContestData() {
            if (confirm('Are you sure you want to clear ALL contest data from localStorage? This cannot be undone!')) {
                // Clear all contest-related keys
                const keys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('contest_entries_') || key.startsWith('entries_') || key === 'contest_entries')) {
                        keys.push(key);
                    }
                }
                
                keys.forEach(key => {
                    console.log(`üóëÔ∏è Removing ${key}`);
                    localStorage.removeItem(key);
                });
                
                alert(`Cleared all contest data (${keys.length} keys removed)`);
                loadContestData(); // Reload the page data
            }
        }
        
        async function completeContest() {
            const dateInput = document.getElementById('contest-date');
            const contestDate = dateInput.value;
            
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }
            
            if (!confirm(`Complete contest for ${contestDate}? This will mark all entries as completed and prevent new entries.`)) {
                return;
            }
            
            try {
                console.log(`üèÅ Completing contest for ${contestDate}`);
                
                if (backend) {
                    const result = await backend.completeContest(contestDate);
                    
                    if (result.success) {
                        alert(`Contest completed! ${result.entriesCompleted} entries marked as completed.`);
                        loadContestData(); // Reload to show updated status
                    } else {
                        alert('Failed to complete contest: ' + result.error);
                    }
                } else {
                    alert('Backend not initialized');
                }
                
            } catch (error) {
                console.error('Failed to complete contest:', error);
                alert('Error completing contest: ' + error.message);
            }
        }

        async function markPayoutComplete() {
            if (!currentPayoutEntry) return;
            
            try {
                // Update entry status
                currentPayoutEntry.payoutStatus = 'completed';
                currentPayoutEntry.payoutTimestamp = new Date().toISOString();
                
                // In production, update Firebase
                if (integration && integration.db) {
                    await integration.db.collection('contest_entries')
                        .doc(currentPayoutEntry.id)
                        .update({
                            payoutStatus: 'completed',
                            payoutTimestamp: currentPayoutEntry.payoutTimestamp
                        });
                }
                
                alert('‚úÖ Payout marked as complete!');
                closePayoutModal();
                loadContestData(); // Refresh the table
                
            } catch (error) {
                console.error('Failed to update payout status:', error);
                alert('Failed to update payout status: ' + error.message);
            }
        }
        
        // Function to update game progress display
        function updateGameProgressDisplay(games) {
            const progressDiv = document.getElementById('game-progress');
            const contentDiv = document.getElementById('game-progress-content');
            
            if (!games || games.length === 0) {
                progressDiv.style.display = 'none';
                return;
            }
            
            const completed = games.filter(g => g.status === 'Final').length;
            const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
            const scheduled = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
            const warmup = games.filter(g => g.status === 'Warmup').length;
            
            let html = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #4CAF50; font-weight: bold;">${completed}</div>
                        <div style="color: #888; font-size: 0.9em;">‚úÖ Completed</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #ff9900; font-weight: bold;">${inProgress}</div>
                        <div style="color: #888; font-size: 0.9em;">üîÑ Live</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #2196F3; font-weight: bold;">${warmup}</div>
                        <div style="color: #888; font-size: 0.9em;">üî• Warmup</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 1.5em; color: #666; font-weight: bold;">${scheduled}</div>
                        <div style="color: #888; font-size: 0.9em;">üìÖ Scheduled</div>
                    </div>
                </div>
            `;
            
            // Show ALL games in a detailed format
            html += `<div style="border-top: 1px solid #444; padding-top: 15px;">`;
            html += `<h4 style="color: #ffa500; margin: 0 0 15px 0;">ÔøΩ All Games Today:</h4>`;
            
            // Group games by status
            const gamesByStatus = {
                'Live/In Progress': games.filter(g => g.status === 'Live' || g.status === 'In Progress'),
                'Final': games.filter(g => g.status === 'Final'),
                'Warmup': games.filter(g => g.status === 'Warmup'),
                'Scheduled': games.filter(g => g.status === 'Preview' || g.status === 'Scheduled')
            };
            
            Object.entries(gamesByStatus).forEach(([status, statusGames]) => {
                if (statusGames.length === 0) return;
                
                const statusColors = {
                    'Live/In Progress': '#ff9900',
                    'Final': '#4CAF50',
                    'Warmup': '#2196F3',
                    'Scheduled': '#666'
                };
                
                const statusEmojis = {
                    'Live/In Progress': 'üî¥',
                    'Final': '‚úÖ',
                    'Warmup': 'üî•',
                    'Scheduled': 'üìÖ'
                };
                
                html += `<div style="margin-bottom: 15px;">`;
                html += `<h5 style="color: ${statusColors[status]}; margin: 0 0 8px 0; font-size: 0.9em;">${statusEmojis[status]} ${status} (${statusGames.length})</h5>`;
                
                statusGames.forEach(game => {
                    const gameTime = game.gameTime ? new Date(game.gameTime).toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit'
                    }) : '';
                    
                    html += `
                        <div style="background: #1a1a1a; padding: 10px; margin: 5px 0; border-radius: 6px; border-left: 3px solid ${statusColors[status]};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="font-weight: bold; color: white;">
                                    ${game.awayTeam} @ ${game.homeTeam}
                                </div>
                                <div style="text-align: right;">
                                    ${game.awayScore !== undefined && game.homeScore !== undefined ? 
                                        `<span style="color: #4CAF50; font-weight: bold; font-size: 1.1em;">${game.awayScore} - ${game.homeScore}</span>` : 
                                        `<span style="color: #888;">${gameTime}</span>`
                                    }
                                </div>
                            </div>
                            ${game.inning ? `<div style="color: #888; font-size: 0.8em; margin-top: 4px;">${game.inning}</div>` : ''}
                            ${game.gameId ? `<div style="color: #666; font-size: 0.7em; font-family: monospace;">${game.gameId}</div>` : ''}
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            html += `</div>`;
            
            contentDiv.innerHTML = html;
            progressDiv.style.display = 'block';
        }
        
        function updateStats(stats) {
            console.log('üìä Updating stats with:', stats);
            
            // Handle both direct stats object and nested stats object
            const actualStats = stats.stats || stats;
            
            document.getElementById('total-entries').textContent = actualStats.totalEntries || 0;
            document.getElementById('prize-pool').textContent = (actualStats.prizePool || 0) + ' NUTS';
            document.getElementById('contest-status').textContent = 
                (actualStats.totalEntries || 0) >= 2 ? 'Active' : 'Needs ' + (2 - (actualStats.totalEntries || 0)) + ' more';
            
            // Handle avgScore safely
            const avgScore = actualStats.avgScore || actualStats.averageScore || 0;
            document.getElementById('avg-score').textContent = Number(avgScore).toFixed(1);
        }
        
        function updateEntriesTable(entries) {
            if (currentContestType === 'nfl') {
                updateNFLEntriesTable(entries);
                return;
            }
            
            const tbody = document.getElementById('entries-tbody');
            
            if (entries.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; color: #888;">
                            No entries for this date
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Sort entries by score (descending) for leaderboard effect
            const sortedEntries = [...entries].sort((a, b) => (b.score || 0) - (a.score || 0));
            
            // Check if scores are calculated and from database
            const hasScores = sortedEntries.some(entry => entry.score !== undefined);
            const contestDate = document.getElementById('contest-date').value;
            const scoreSource = hasScores ? (entries[0]?.lastScoreUpdate ? 'database' : 'calculated') : 'none';
            
            tbody.innerHTML = sortedEntries.map((entry, index) => {
                // Create detailed picks display
                const picksHtml = formatPicksDisplay(entry.picks || {});
                
                // Determine rank styling
                const rank = index + 1;
                const rankStyle = rank === 1 ? 'color: #FFD700; font-weight: bold;' : // Gold
                                 rank === 2 ? 'color: #C0C0C0; font-weight: bold;' : // Silver  
                                 rank === 3 ? 'color: #CD7F32; font-weight: bold;' : // Bronze
                                 'color: #888;';
                
                // Score display with indicators
                let scoreDisplay = '';
                if (entry.score !== undefined) {
                    const scoreIndicator = scoreSource === 'database' ? 'üíæ' : 'üîÑ';
                    const scoreTooltip = scoreSource === 'database' ? 'Score loaded from database' : 'Score calculated this session';
                    scoreDisplay = `<span class="score-badge" title="${scoreTooltip}" style="font-size: 1.1em; ${rank <= 3 ? 'background: ' + (rank === 1 ? '#FFD700' : rank === 2 ? '#C0C0C0' : '#CD7F32') + '; color: #000;' : ''}">${entry.score} ${scoreIndicator}</span>`;
                } else {
                    scoreDisplay = '<span style="color: #666;">Not calculated</span>';
                }
                
                return `
                <tr style="${rank <= 3 && hasScores ? 'background: rgba(255, 215, 0, 0.05);' : ''} cursor: pointer;" onclick="showDetailedPicks('${entry.id}')" class="clickable-row">
                    <td style="font-family: monospace; font-size: 0.85em;">
                        <span style="${rankStyle}">#${rank}</span><br>
                        ${entry.id.substring(0, 8)}...
                    </td>
                    <td>
                        <strong>${entry.userName}</strong>
                        ${rank <= 3 && hasScores ? `<br><small style="${rankStyle}">${rank === 1 ? 'üëë Leader' : rank === 2 ? 'ü•à 2nd Place' : 'ü•â 3rd Place'}</small>` : ''}
                    </td>
                    <td>
                        ${entry.twitterHandle ? 
                            `<a href="https://twitter.com/${entry.twitterHandle.replace('@', '')}" 
                                target="_blank" 
                                style="color: #1DA1F2; text-decoration: none;" onclick="event.stopPropagation();">
                                ${entry.twitterHandle}
                            </a>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td style="font-family: monospace; font-size: 0.75em;">
                        ${entry.walletAddress ? 
                            `<span title="${entry.walletAddress}" style="cursor: help;">
                                ${entry.walletAddress.substring(0, 8)}...${entry.walletAddress.substring(entry.walletAddress.length - 4)}
                            </span>` : 
                            '<span style="color: #666;">-</span>'}
                    </td>
                    <td class="picks-preview" style="max-width: 200px;">
                        ${picksHtml}
                        <div style="margin-top: 5px; font-size: 0.7em; color: #ffa500;">üëÜ Click row for details</div>
                    </td>
                    <td style="text-align: center;">
                        <strong>${entry.tiebreakerRuns || 0}</strong> runs
                    </td>
                    <td style="text-align: center;">
                        ${scoreDisplay}
                    </td>
                    <td style="text-align: center;">${entry.prizeWon || 0} NUTS</td>
                    <td>
                        <span style="color: ${
                            entry.status === 'won' ? '#4CAF50' : 
                            entry.status === 'active' ? '#2196F3' : '#888'
                        }">
                            ${entry.status || 'pending'}
                        </span>
                        ${entry.contestStatus === 'completed' ? 
                            '<br><small style="color: #ff9900;">Completed</small>' : 
                            ''}
                        ${entry.status === 'won' && entry.prizeWon > 0 ? `
                            <br><small style="color: #4CAF50;">Won ${entry.prizeWon} NUTS</small>
                        ` : ''}
                    </td>
                    <td style="font-size: 0.85em; color: #888;">
                        ${new Date(entry.timestamp || entry.paymentTimestamp).toLocaleTimeString()}
                    </td>
                </tr>
            `;
            }).join('');
            
            // Add status message about scores at the top
            if (hasScores) {
                const statusMessage = scoreSource === 'database' ? 
                    'üíæ Scores loaded from database (persistent)' : 
                    'üîÑ Scores calculated this session';
                    
                const statusRow = `
                    <tr style="background: rgba(76, 175, 80, 0.1);">
                        <td colspan="10" style="text-align: center; padding: 10px; color: #4CAF50; font-size: 0.9em;">
                            ${statusMessage} ‚Ä¢ ${sortedEntries.length} entries sorted by score
                        </td>
                    </tr>
                `;
                tbody.innerHTML = statusRow + tbody.innerHTML;
            }
        }
                        ${new Date(entry.timestamp || entry.paymentTimestamp).toLocaleTimeString()}
                    </td>
                </tr>
            `;
            }).join('');
        }
        
        // NEW FUNCTION: Format picks for display
        function formatPicksDisplay(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<span style="color: #666;">No picks</span>';
            }
            
            let html = `<div style="font-size: 0.8em;">`;
            let pickCount = 0;
            const maxDisplayPicks = 3; // Show first 3 picks, then "..."
            
            Object.entries(picks).forEach(([gameId, pick]) => {
                if (pickCount < maxDisplayPicks) {
                    // Try to get team names from the game ID or use generic names
                    const teams = getTeamNamesFromGameId(gameId);
                    const pickedTeam = pick === 'home' ? teams.home : teams.away;
                    
                    html += `
                        <div style="margin: 2px 0; padding: 2px 4px; background: #2a2a2a; border-radius: 3px; display: flex; justify-content: space-between;">
                            <span style="color: #888; font-size: 0.7em;">${teams.away} @ ${teams.home}</span>
                            <span style="color: #ffa500; font-weight: bold;">${pickedTeam}</span>
                        </div>
                    `;
                }
                pickCount++;
            });
            
            if (pickCount > maxDisplayPicks) {
                html += `<div style="color: #666; font-size: 0.7em; text-align: center; margin-top: 4px;">...and ${pickCount - maxDisplayPicks} more</div>`;
            }
            
            html += `</div>`;
            return html;
        }
        
        // Helper function to extract team names from game ID
        function getTeamNamesFromGameId(gameId) {
            return {
                away: 'Away',
                home: 'Home'
            };
        }
        
        // NEW FUNCTION: Fetch real game results from MLB API
        async function fetchRealGameResults(contestDate = null, showAlert = true) {
            const dateToCheck = contestDate || document.getElementById('contest-date').value;
            
            if (!dateToCheck) {
                if (showAlert) alert('Please select a date first');
                return {};
            }
            
            try {
                console.log(`üîÑ Fetching real MLB game results for ${dateToCheck}...`);
                
                if (showAlert) {
                    document.body.style.cursor = 'wait';
                }
                
                // Initialize MLB Schedule API if not available
                if (!window.mlbSchedule) {
                    console.log('üì° Loading MLB Schedule API...');
                    window.mlbSchedule = new MLBScheduleFree();
                }
                
                // Create date object properly to avoid timezone issues
                const dateParts = dateToCheck.split('-');
                const gameDate = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                
                console.log(`üóìÔ∏è Processing game results for: ${dateToCheck}`);
                console.log(`üóìÔ∏è Created date object: ${gameDate.toDateString()} (${gameDate.toISOString()})`);
                
                // Use the new getGameResults method that returns processed results
                const gameResults = await window.mlbSchedule.getGameResults(gameDate);
                
                // Always get games to show progress (regardless of completed games)
                const allGames = await window.mlbSchedule.getGamesForDate(gameDate);
                updateGameProgressDisplay(allGames);
                
                const completedGames = Object.keys(gameResults).filter(key => key !== 'lastGameRuns').length;
                
                console.log(`üìÖ Found ${completedGames} completed games for ${dateToCheck}`);
                
                // Store the last game total runs globally for tiebreaker calculations
                window.lastGameActualRuns = gameResults.lastGameRuns || 0;
                console.log(`üèÉ Last game total runs for tiebreaker: ${window.lastGameActualRuns}`);
                
                if (completedGames === 0) {
                    if (showAlert) {
                        const games = await window.mlbSchedule.getGamesForDate(gameDate);
                        const inProgress = games.filter(g => g.status === 'Live' || g.status === 'In Progress').length;
                        const notStarted = games.filter(g => g.status === 'Preview' || g.status === 'Scheduled').length;
                        
                        alert(`üìä Game Status Update for ${dateToCheck}:\n\n‚úÖ Completed: 0\nüîÑ In Progress: ${inProgress}\nüìÖ Not Started: ${notStarted}\n\nNo games have finished yet. Check back later!`);
                    }
                    return {};
                }
                
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    
                    alert(`üìä Game Results Updated!\n\n‚úÖ Completed Games: ${completedGames}\nüèÉ Total Runs: ${gameResults.lastGameRuns || 0}\n\nContest scores will be updated automatically.`);
                    
                    // Automatically recalculate scores for entries
                    await updateEntryScores(gameResults);
                    loadContestData(); // Refresh the display
                }
                
                return gameResults;
                
            } catch (error) {
                console.error('‚ùå Failed to fetch real game results:', error);
                if (showAlert) {
                    document.body.style.cursor = 'default';
                    alert(`Failed to fetch game results: ${error.message}\n\nPlease check your internet connection and try again.`);
                }
                return {};
            }
        }
        
        // ENHANCED FUNCTION: Display contest winners with proper data structure handling
        function displayContestWinners(winners, contestDate, prizePool) {
            if (!winners || winners.length === 0) {
                console.log('‚ö†Ô∏è No winners to display');
                return;
            }
            
            console.log('üèÜ Displaying contest winners:', winners);
            
            // Debug: Log the first winner's properties to see what fields are available
            if (winners.length > 0) {
                console.log('üîç First winner object structure:', Object.keys(winners[0]));
                console.log('üîç First winner full object:', winners[0]);
                console.log('üîç Checking wallet fields in winner object:');
                console.log('  - walletAddress:', winners[0].walletAddress);
                console.log('  - playerWallet:', winners[0].playerWallet);
                console.log('  - wallet:', winners[0].wallet);
                console.log('  - xrpAddress:', winners[0].xrpAddress);
                
                // Also check if winner has entry object
                if (winners[0].entry) {
                    console.log('üîç Checking wallet fields in entry object:');
                    console.log('  - entry.walletAddress:', winners[0].entry.walletAddress);
                    console.log('  - entry.playerWallet:', winners[0].entry.playerWallet);
                    console.log('  - entry.wallet:', winners[0].entry.wallet);
                    console.log('  - entry.xrpAddress:', winners[0].entry.xrpAddress);
                }
            }
            
            const winnersDisplay = document.getElementById('winners-display');
            const winnersContent = document.getElementById('winners-content');
            
            // Create winners HTML
            let winnersHtml = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="color: #4CAF50; font-size: 1.2em; margin-bottom: 10px;">
                        Contest Date: ${contestDate} | Total Prize Pool: ${prizePool} NUTS
                    </div>
                    <div style="color: #888; font-size: 0.9em;">
                        Winners calculated based on game results and tiebreaker
                    </div>
                </div>
                
                <div style="display: grid; gap: 15px;">
            `;
            
            winners.forEach((winner, index) => {
                const place = winner.place || (index + 1);
                const medal = place === 1 ? 'ü•á' : place === 2 ? 'ü•à' : place === 3 ? 'ü•â' : 'üèÖ';
                const bgColor = place === 1 ? 'rgba(255, 215, 0, 0.1)' : 
                               place === 2 ? 'rgba(192, 192, 192, 0.1)' : 
                               place === 3 ? 'rgba(205, 127, 50, 0.1)' : 'rgba(136, 136, 136, 0.1)';
                
                // Access entry data correctly - winner.entry contains the entry object
                const entry = winner.entry || winner;
                const walletAddress = entry.walletAddress || entry.playerWallet || entry.wallet || entry.xrpAddress ||
                                    winner.walletAddress || winner.playerWallet || winner.wallet || winner.xrpAddress;
                const score = entry.score !== undefined ? entry.score : winner.score || 0;
                const tiebreakerRuns = entry.tiebreakerRuns || entry.tiebreakerPoints || winner.tiebreakerRuns || winner.tiebreakerPoints || 0;
                const prize = winner.prize || winner.prizeWon || entry.prizeWon || 0;
                const userName = entry.userName || entry.name || winner.userName || winner.name || 'Anonymous Player';
                const twitterHandle = entry.twitterHandle || winner.twitterHandle;
                const entryId = entry.id || entry.entryId || winner.id || winner.entryId;
                
                winnersHtml += `
                    <div style="
                        background: ${bgColor}; 
                        border: 2px solid ${place <= 3 ? '#4CAF50' : '#666'}; 
                        border-radius: 8px; 
                        padding: 15px; 
                        display: grid; 
                        grid-template-columns: auto 1fr auto auto auto; 
                        align-items: center; 
                        gap: 15px;
                    ">
                        <div style="font-size: 2em;">${medal}</div>
                        <div>
                            <div style="color: #4CAF50; font-weight: bold; font-size: 1.1em;">
                                ${userName}
                            </div>
                            <div style="color: #888; font-size: 0.9em; margin: 5px 0;">
                                ${twitterHandle ? `X: ${twitterHandle}` : 'No X handle'}
                            </div>
                            ${walletAddress ? `
                                <div style="color: #4CAF50; font-size: 0.85em; font-family: monospace; background: rgba(76, 175, 80, 0.1); padding: 4px 8px; border-radius: 4px; margin-top: 8px;">
                                    <div style="color: #888; font-size: 0.8em; margin-bottom: 2px;">Wallet Address:</div>
                                    <div style="word-break: break-all; line-height: 1.3;">
                                        ${walletAddress}
                                    </div>
                                </div>
                            ` : `
                                <div style="color: #ff4444; font-size: 0.85em; background: rgba(255, 68, 68, 0.1); padding: 4px 8px; border-radius: 4px; margin-top: 8px;">
                                    ‚ùå No wallet address provided
                                </div>
                            `}
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #4CAF50; font-weight: bold;">Score: ${score}</div>
                            <div style="color: #888; font-size: 0.9em;">Tiebreaker: ${tiebreakerRuns}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #4CAF50; font-weight: bold; font-size: 1.2em;">
                                ${prize} NUTS
                            </div>
                            <div style="color: #888; font-size: 0.8em;">${place === 1 ? '50%' : place === 2 ? '30%' : place === 3 ? '20%' : '0%'} of pool</div>
                        </div>
                        <div>
                            ${walletAddress ? `
                                <button onclick="showPayoutOptions('${entryId}')" 
                                        style="background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                                    üí∞ Payout
                                </button>
                                <div style="margin-top: 5px;">
                                    <button onclick="navigator.clipboard.writeText('${walletAddress}')" 
                                            style="background: #2196F3; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8em;"
                                            title="Copy wallet address">
                                        üìã Copy
                                    </button>
                                </div>
                            ` : `
                                <div style="color: #ff4444; font-size: 0.8em; text-align: center;">
                                    No wallet<br>address
                                </div>
                            `}
                        </div>
                    </div>
                `;
            });
            
            winnersHtml += `</div>`;
            
            winnersContent.innerHTML = winnersHtml;
            winnersDisplay.style.display = 'block';
            
            // Scroll to winners display
            winnersDisplay.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        
        // NEW FUNCTION: Hide winners display
        function hideWinners() {
            document.getElementById('winners-display').style.display = 'none';
        }
        
        // NEW FUNCTION: Export winners list
        function exportWinners() {
            const winnersContent = document.getElementById('winners-content');
            if (!winnersContent.innerHTML.trim()) {
                alert('No winners data to export');
                return;
            }
            
            // Extract winner data from current entries
            const winners = currentEntries
                .filter(entry => entry.prizeWon && entry.prizeWon > 0)
                .sort((a, b) => (b.prizeWon || 0) - (a.prizeWon || 0));
            
            if (winners.length === 0) {
                alert('No winners found to export');
                return;
            }
            
            // Create CSV
            const headers = ['Place', 'Player Name', 'X Handle', 'Wallet Address', 'Score', 'Tiebreaker', 'Prize (NUTS)', 'Entry ID'];
            const rows = winners.map((winner, index) => [
                (index + 1).toString(),
                winner.userName || winner.name || 'Anonymous',
                winner.twitterHandle || '',
                winner.walletAddress || '',
                (winner.score || 0).toString(),
                (winner.tiebreakerRuns || winner.tiebreakerPoints || 0).toString(),
                (winner.prizeWon || 0).toString(),
                winner.id || winner.entryId || ''
            ]);
            
            const csv = [headers, ...rows].map(row => 
                row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
            ).join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `contest_winners_${document.getElementById('contest-date').value}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('üìã Winners list exported successfully');
        }
        
        // Enhanced scoring function with detailed logging
        async function updateEntryScores(gameResults) {
            if (currentEntries.length === 0 || Object.keys(gameResults).length === 0) {
                return;
            }
            
            console.log('üèÜ Updating entry scores with real game results...');
            console.log('üéÆ Game Results:', gameResults);
            console.log('üìã Available game IDs in results:', Object.keys(gameResults));
            
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                console.error('‚ùå No contest date selected');
                return;
            }
            
            try {
                // Use enhanced backend for Firebase-compatible score persistence
                console.log('üîß Initializing enhanced backend for Firebase score persistence...');
                const enhancedBackend = new ContestBackendEnhanced();
                await enhancedBackend.init();
                
                // Use the enhanced backend's updateGameResults method for CORS-compliant Firebase operations
                console.log('ÔøΩ Persisting scores to Firebase via enhanced backend...');
                const result = await enhancedBackend.updateGameResults(contestDate, gameResults);
                
                if (result && result.allEntries) {
                    // Update current entries with the persisted scores from Firebase
                    currentEntries = result.allEntries;
                    console.log(`‚úÖ Successfully persisted ${result.allEntries.length} entry scores to Firebase`);
                    
                    // Clear temporary scores since we now have persisted data
                    if (window.tempScores) {
                        delete window.tempScores;
                    }
                    
                    // Display winner information if available
                    if (result.winners && result.winners.length > 0) {
                        console.log('üèÜ Contest winners:', result.winners);
                        result.winners.forEach((winner, index) => {
                            console.log(`${index + 1}. ${winner.entry?.userName || winner.userName} - Score: ${winner.entry?.score || winner.score} - Prize: ${winner.prize} NUTS`);
                        });
                    }
                    
                    // Show status information
                    if (result.status === 'cancelled') {
                        console.warn('‚ö†Ô∏è Contest cancelled:', result.reason);
                        alert(`Contest cancelled: ${result.reason}\nEntries: ${result.totalEntries}, Minimum required: ${result.minimumRequired}`);
                    } else if (result.status === 'completed') {
                        console.log('üéâ Contest completed successfully');
                        if (result.totalPrizePool) {
                            console.log(`üí∞ Total prize pool: ${result.totalPrizePool} NUTS`);
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è No entries updated - this may indicate an issue with Firebase persistence');
                }
                
                // Refresh the display using enhanced display if available
                if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                    window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                } else {
                    updateEntriesTable(currentEntries);
                }
                
                // Reload the contest data to reflect the updated scores
                await loadContestData();
                
                console.log('üîÑ Contest data reloaded with updated scores from Firebase');
                
            } catch (error) {
                console.error('‚ùå Failed to persist scores to Firebase:', error);
                
                // Fallback: Calculate and display scores locally without Firebase persistence
                console.log('üîÑ Falling back to local score calculation...');
                
                try {
                    let updatedCount = 0;
                    
                    // Calculate scores for each entry locally
                    for (const entry of currentEntries) {
                        if (!entry.picks) {
                            console.log(`‚ùå ${entry.userName}: No picks found`);
                            continue;
                        }
                        
                        let newScore = 0;
                        console.log(`üîç Processing ${entry.userName}...`);
                        
                        // Calculate score based on real game results
                        Object.keys(entry.picks).forEach(gameId => {
                            const userPick = entry.picks[gameId]; // 'home' or 'away'
                            
                            // Try exact match first
                            let gameResult = gameResults[gameId];
                            
                            // If no exact match, try to find a similar game ID
                            if (!gameResult) {
                                const possibleMatches = Object.keys(gameResults).filter(resultGameId => {
                                    if (resultGameId.includes(gameId) || gameId.includes(resultGameId)) {
                                        return true;
                                    }
                                    
                                    const extractGamePk = (id) => {
                                        const match = id.match(/(\d+)$/);
                                        return match ? match[1] : null;
                                    };
                                    
                                    const userGamePk = extractGamePk(gameId);
                                    const resultGamePk = extractGamePk(resultGameId);
                                    
                                    return userGamePk && resultGamePk && userGamePk === resultGamePk;
                                });
                                
                                if (possibleMatches.length > 0) {
                                    gameResult = gameResults[possibleMatches[0]];
                                    console.log(`  üîÑ Matched ${gameId} to ${possibleMatches[0]}`);
                                }
                            }
                            
                            if (gameResult && (gameResult.status === 'completed' || gameResult.status === 'Final')) {
                                const isCorrect = userPick === gameResult.winner;
                                if (isCorrect) {
                                    newScore++;
                                }
                            }
                        });
                        
                        const oldScore = entry.score || 0;
                        entry.score = newScore;
                        
                        console.log(`üìä ${entry.userName}: ${oldScore} ‚Üí ${newScore} points`);
                        updatedCount++;
                        
                        // Store in temporary scores object for display
                        if (!window.tempScores) {
                            window.tempScores = {};
                        }
                        window.tempScores[entry.id] = {
                            score: entry.score,
                            userName: entry.userName,
                            timestamp: Date.now()
                        };
                    }
                    
                    console.log(`‚úÖ Calculated ${updatedCount} entry scores locally (NOT saved to Firebase)`);
                    
                    // Refresh the display
                    if (window.enhancedDisplay && window.enhancedDisplay.displayAdminEntries) {
                        window.enhancedDisplay.displayAdminEntries(currentEntries, contestDate);
                    } else {
                        updateEntriesTable(currentEntries);
                    }
                    
                    alert(`‚ö†Ô∏è Firebase Error: ${error.message}\n\nScores calculated correctly but not saved to database.\nDisplaying local calculations only.`);
                    
                } catch (fallbackError) {
                    console.error('‚ùå Fallback calculation also failed:', fallbackError);
                    alert(`Failed to calculate scores: ${fallbackError.message}`);
                }
            }
        }
        
        // NEW FUNCTION: Show detailed picks modal
        function showDetailedPicks(entryId) {
            const entry = currentEntries.find(e => e.id === entryId);
            if (!entry) return;
            
            // Create or show the detailed picks modal
            let modal = document.getElementById('detailed-picks-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'detailed-picks-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.8);
                    z-index: 1001;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div style="background: #1a1a1a; border: 2px solid #ffa500; border-radius: 12px; padding: 30px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
                    <button onclick="closeDetailedPicks()" style="position: absolute; top: 10px; right: 10px; background: #ffa500; border: none; color: #000; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-weight: bold;">√ó</button>
                    
                    <h2 style="color: #ffa500; margin-bottom: 20px;">üìã Detailed Picks</h2>
                    
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 10px 0; color: #fff;">${entry.userName}</h3>
                        <div style="font-size: 0.9em; color: #888;">
                            Entry ID: ${entry.id}<br>
                            Score: <strong style="color: #4CAF50;">${entry.score || 0}</strong> correct picks<br>
                            Tiebreaker: ${entry.tiebreakerRuns || 0} runs
                        </div>
                    </div>
                    
                    <div id="detailed-picks-content">
                        ${formatDetailedPicks(entry.picks || {})}
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        function closeDetailedPicks() {
            const modal = document.getElementById('detailed-picks-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function formatDetailedPicks(picks) {
            if (!picks || Object.keys(picks).length === 0) {
                return '<div style="text-align: center; color: #888; padding: 20px;">No picks found</div>';
            }
            
            let html = `<div style="font-size: 0.9em;">`;
            
            Object.entries(picks).forEach(([gameId, pick], index) => {
                const teams = getTeamNamesFromGameId(gameId);
                const pickedTeam = pick === 'home' ? teams.home : teams.away;
                
                html += `
                    <div style="background: #2a2a2a; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 3px solid #ffa500;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="color: #fff;">Game ${index + 1}</strong><br>
                                <span style="color: #888; font-size: 0.8em;">${teams.away} @ ${teams.home}</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffa500; font-weight: bold; font-size: 1.1em;">Picked: ${pickedTeam}</div>
                                <div style="color: #666; font-size: 0.7em; font-family: monospace;">${gameId}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            return html;
        }
        
        // Initialize page when loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize with MLB contest as default
        });

        // ===============================================
        // SIMPLIFIED WORKFLOW FUNCTIONS
        // ===============================================
        
        // Toggle advanced controls visibility
        function toggleAdvancedControls() {
            const controls = document.getElementById('advanced-controls');
            if (controls.style.display === 'none') {
                controls.style.display = 'block';
            } else {
                controls.style.display = 'none';
            }
        }

        // NEW SIMPLIFIED WORKFLOW FUNCTIONS
        
        // Simplified function: Calculate scores and update the entries table immediately
        async function calculateAndUpdateScores() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üßÆ Starting score calculation and table update...');
                
                // 1. Load entries if not already loaded
                if (currentEntries.length === 0) {
                    console.log('üìä Loading entries first...');
                    await loadContestData();
                }

                // 2. Fetch real game results
                console.log('‚öæ Fetching game results...');
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }

                // 3. Calculate scores for all entries
                console.log('üî¢ Calculating scores...');
                await updateEntryScores(gameResults);

                // 4. Save scores to Firebase database for persistence
                console.log('üíæ Saving scores to database...');
                await saveScoresToFirebase(contestDate);

                // 5. Update the entries table immediately
                console.log('üìä Updating entries table...');
                updateEntriesTable(currentEntries);

                // 6. Update stats
                const stats = {
                    totalEntries: currentEntries.length,
                    prizePool: currentEntries.length * 50,
                    avgScore: currentEntries.reduce((sum, e) => sum + (e.score || 0), 0) / currentEntries.length
                };
                updateStats(stats);

                alert(`‚úÖ Scores calculated and saved for ${currentEntries.length} entries!`);

            } catch (error) {
                console.error('‚ùå Failed to calculate scores:', error);
                alert('Failed to calculate scores: ' + error.message);
            }
        }

        // Simplified function: Resolve contest and determine winners
        async function resolveContestWithWinners() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            const minimumEntries = 2; // Minimum entries required

            if (currentEntries.length < minimumEntries) {
                alert(`Need at least ${minimumEntries} entries to resolve contest. Current: ${currentEntries.length}`);
                return;
            }

            try {
                console.log('üèÜ Starting contest resolution...');

                // 1. Ensure scores are calculated
                const hasScores = currentEntries.every(entry => entry.score !== undefined);
                if (!hasScores) {
                    console.log('üìä Calculating scores first...');
                    await calculateAndUpdateScores();
                }

                // 2. Determine winners
                console.log('ü•á Determining winners...');
                const winners = determineWinners(currentEntries);

                // 3. Save contest resolution to database
                console.log('üíæ Saving contest resolution...');
                await saveContestResolution(contestDate, winners);

                // 4. Display winners
                console.log('üéâ Displaying winners...');
                const prizePool = currentEntries.length * 50;
                displayContestWinners(winners, contestDate, prizePool);

                // 5. Update entries table to show final results
                updateEntriesTable(currentEntries);

                console.log('‚úÖ Contest resolved successfully!');

            } catch (error) {
                console.error('‚ùå Failed to resolve contest:', error);
                alert('Failed to resolve contest: ' + error.message);
            }
        }

        // Enhanced function to save scores to Firebase database for persistence
        async function saveScoresToFirebase(contestDate) {
            if (!backend || !currentEntries.length) {
                console.warn('‚ö†Ô∏è No backend or entries to save');
                return;
            }

            try {
                console.log('üíæ Saving scores to Firebase database...');
                
                // Save each entry's updated score to Firebase
                const savePromises = currentEntries.map(async (entry) => {
                    if (entry.score !== undefined) {
                        try {
                            // Update the entry in Firebase with the calculated score
                            await backend.updateEntryScore(entry.id, {
                                score: entry.score,
                                lastScoreUpdate: new Date().toISOString(),
                                contestDate: contestDate
                            });
                            console.log(`‚úÖ Saved score for entry ${entry.id}: ${entry.score}`);
                        } catch (updateError) {
                            console.error(`‚ùå Failed to save score for entry ${entry.id}:`, updateError);
                        }
                    }
                });

                await Promise.all(savePromises);
                
                // Also save a summary to prevent recalculation
                const scoresSummary = {
                    contestDate: contestDate,
                    totalEntries: currentEntries.length,
                    scoresCalculated: true,
                    lastCalculation: new Date().toISOString(),
                    averageScore: currentEntries.reduce((sum, e) => sum + (e.score || 0), 0) / currentEntries.length
                };

                await backend.saveContestSummary(contestDate, scoresSummary);
                console.log('üíæ Contest summary saved to Firebase');

            } catch (error) {
                console.error('‚ùå Failed to save scores to Firebase:', error);
                throw error;
            }
        }

        // Enhanced function to save contest resolution
        async function saveContestResolution(contestDate, winners) {
            if (!backend) {
                console.warn('‚ö†Ô∏è No backend available for saving contest resolution');
                return;
            }

            try {
                const resolution = {
                    contestDate: contestDate,
                    resolvedAt: new Date().toISOString(),
                    winners: winners,
                    totalEntries: currentEntries.length,
                    prizePool: currentEntries.length * 50,
                    status: 'completed'
                };

                await backend.saveContestResolution(contestDate, resolution);
                console.log('‚úÖ Contest resolution saved to Firebase');

            } catch (error) {
                console.error('‚ùå Failed to save contest resolution:', error);
                throw error;
            }
        }

        // Enhanced function to determine winners with proper tiebreaker handling
        function determineWinners(entries) {
            if (!entries || entries.length === 0) return [];

            // Sort by score (descending), then by tiebreaker (ascending - closest to actual)
            const sortedEntries = [...entries].sort((a, b) => {
                const scoreA = a.score || 0;
                const scoreB = b.score || 0;
                
                if (scoreA !== scoreB) {
                    return scoreB - scoreA; // Higher score wins
                }
                
                // If scores are tied, use tiebreaker (lower tiebreaker difference wins)
                const tiebreakerA = a.tiebreakerRuns || 0;
                const tiebreakerB = b.tiebreakerRuns || 0;
                
                // This would need actual total runs to determine winner properly
                // For now, lower tiebreaker wins (assuming it's closer to actual)
                return tiebreakerA - tiebreakerB;
            });

            // Calculate prizes (50% to 1st, 30% to 2nd, 20% to 3rd)
            const totalPrizePool = entries.length * 50;
            const prizes = [
                Math.floor(totalPrizePool * 0.5), // 1st place: 50%
                Math.floor(totalPrizePool * 0.3), // 2nd place: 30%
                Math.floor(totalPrizePool * 0.2)  // 3rd place: 20%
            ];

            // Create winner objects
            const winners = sortedEntries.slice(0, 3).map((entry, index) => ({
                place: index + 1,
                entry: entry,
                prize: prizes[index] || 0
            }));

            // Update the original entries with prize information
            winners.forEach(winner => {
                const originalEntry = entries.find(e => e.id === winner.entry.id);
                if (originalEntry) {
                    originalEntry.prizeWon = winner.prize;
                    originalEntry.status = 'won';
                    originalEntry.place = winner.place;
                }
            });

            return winners;
        }

        // All-in-one contest processing: Load data ‚Üí Fetch games ‚Üí Calculate scores ‚Üí Save to DB ‚Üí Update display
        async function processFullContest() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üöÄ Starting full contest processing...');
                
                // Step 1: Load contest data
                console.log('üìã Step 1: Loading contest data...');
                await loadContestData();
                
                if (currentEntries.length === 0) {
                    alert('No entries found for this date. Contest processing cancelled.');
                    return;
                }

                // Step 2: Fetch real game results
                console.log('üéÆ Step 2: Fetching game results...');
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot process contest until games finish.');
                    return;
                }

                // Step 3: Calculate and save scores
                console.log('üßÆ Step 3: Calculating scores...');
                await calculateScoresWithGameResults(gameResults);

                // Step 4: Save to database
                console.log('üíæ Step 4: Saving scores to database...');
                await saveScoresToDatabaseWithResults();

                // Step 5: Refresh display
                console.log('üîÑ Step 5: Refreshing display...');
                await loadContestData();

                alert('‚úÖ Contest processing complete! Scores calculated and saved to database.');

            } catch (error) {
                console.error('‚ùå Contest processing failed:', error);
                alert(`Contest processing failed: ${error.message}`);
            }
        }

        // Calculate scores only (without resolving winners)
        async function calculateScoresOnly() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }

            try {
                console.log('üßÆ Calculating scores only...');
                
                // Fetch game results
                const gameResults = await fetchRealGameResults(contestDate, false);
                
                if (Object.keys(gameResults).length === 0) {
                    alert('‚ö†Ô∏è No completed games found yet. Cannot calculate scores until games finish.');
                    return;
                }

                // Calculate scores and update entries table
                await calculateScoresWithGameResults(gameResults);
                
                // Save calculated scores to database
                await saveScoresToDatabaseWithResults();

                // Refresh the entries table to show updated scores
                await loadContestData();

                alert('‚úÖ Scores calculated and saved! Check the entries table for updated scores.');

            } catch (error) {
                console.error('‚ùå Score calculation failed:', error);
                alert(`Score calculation failed: ${error.message}`);
            }
        }

        // Helper function to calculate scores with game results
        async function calculateScoresWithGameResults(gameResults) {
            console.log('üéØ Calculating scores for all entries...');
            
            let updatedCount = 0;
            
            for (const entry of currentEntries) {
                if (!entry.picks) continue;
                
                let score = 0;
                
                // Calculate score based on correct picks
                for (const [gameId, pick] of Object.entries(entry.picks)) {
                    if (gameResults[gameId] && gameResults[gameId].result === pick) {
                        score++;
                    }
                }
                
                // Update entry with calculated score
                entry.score = score;
                updatedCount++;
                
                console.log(`üìä ${entry.userName}: ${score} correct picks`);
            }
            
            console.log(`‚úÖ Updated scores for ${updatedCount} entries`);
            
            // Update the entries table immediately
            updateEntriesTable(currentEntries);
        }

        // Enhanced function to save scores to database with better persistence
        async function saveScoresToDatabaseWithResults() {
            if (currentEntries.length === 0) {
                alert('No entries to save');
                return;
            }

            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            try {
                console.log('üíæ Saving scores to database...');
                
                let savedCount = 0;
                const errors = [];

                for (const entry of currentEntries) {
                    if (entry.score === undefined) continue;

                    try {
                        const response = await fetch(`${backend.baseUrl}/updateEntryScore`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                entryId: entry.id,
                                score: entry.score,
                                contestDate: contestDate,
                                timestamp: new Date().toISOString()
                            })
                        });

                        if (response.ok) {
                            savedCount++;
                            console.log(`‚úÖ Saved score for ${entry.userName}: ${entry.score}`);
                        } else {
                            const errorText = await response.text();
                            errors.push(`${entry.userName}: ${errorText}`);
                        }
                    } catch (error) {
                        errors.push(`${entry.userName}: ${error.message}`);
                    }
                }

                if (savedCount > 0) {
                    console.log(`‚úÖ Successfully saved ${savedCount} scores to database`);
                    
                    // Store in local storage as backup
                    const scoresBackup = {
                        contestDate,
                        timestamp: new Date().toISOString(),
                        entries: currentEntries.map(entry => ({
                            id: entry.id,
                            userName: entry.userName,
                            score: entry.score
                        }))
                    };
                    localStorage.setItem(`scores_${contestDate}`, JSON.stringify(scoresBackup));
                    
                    alert(`‚úÖ Successfully saved ${savedCount} scores to database`);
                } else {
                    throw new Error('No scores were saved successfully');
                }

                if (errors.length > 0) {
                    console.warn('‚ö†Ô∏è Some scores failed to save:', errors);
                }

            } catch (error) {
                console.error('‚ùå Failed to save scores:', error);
                alert(`Failed to save scores: ${error.message}`);
            }
        }

        // Final contest resolution with winner determination and prize distribution
        async function resolveContestFinal() {
            const contestDate = document.getElementById('contest-date').value;
            if (!contestDate) {
                alert('Please select a contest date first');
                return;
            }

            if (currentEntries.length === 0) {
                alert('No entries loaded. Please load contest data first.');
                return;
            }

            // Check if scores are calculated
            const hasScores = currentEntries.some(entry => entry.score !== undefined);
            if (!hasScores) {
                const shouldCalculate = confirm('Scores not calculated yet. Calculate scores first?');
                if (shouldCalculate) {
                    await calculateScoresOnly();
                } else {
                    return;
                }
            }

            try {
                console.log('üèÜ Finalizing contest and determining winners...');
                
                // Use the enhanced contest resolution
                if (window.resolveContest) {
                    const result = await window.resolveContest(contestDate);
                    
                    if (result && result.winners) {
                        // Display the winners
                        displayContestWinners(result.winners, contestDate, result.totalPrizePool || 0);
                        
                        // Show success message
                        alert(`üèÜ Contest finalized successfully!\n\nWinners: ${result.winners.length}\nTotal Prize Pool: ${result.totalPrizePool || 0} NUTS\n\nCheck the winners section above for payout details.`);
                        
                        // Reload the data to show final results
                        await loadContestData();
                    } else {
                        alert('Contest resolution completed, but no result details available. Please check the console for more information.');
                    }
                } else {
                    throw new Error('Contest resolution function not available');
                }

            } catch (error) {
                console.error('‚ùå Failed to finalize contest:', error);
                alert(`Failed to finalize contest: ${error.message}`);
            }
        }

        // Enhanced loadContestData to check for saved scores
        const originalLoadContestData = loadContestData;
        loadContestData = async function() {
            await originalLoadContestData();
            
            // Check for locally saved scores as backup
            const contestDate = document.getElementById('contest-date').value;
            if (contestDate) {
                const savedScores = localStorage.getItem(`scores_${contestDate}`);
                if (savedScores) {
                    try {
                        const scoresData = JSON.parse(savedScores);
                        console.log('üìã Found locally saved scores:', scoresData);
                        
                        // Apply saved scores to current entries if they don't have scores
                        currentEntries.forEach(entry => {
                            if (entry.score === undefined) {
                                const savedEntry = scoresData.entries.find(saved => saved.id === entry.id);
                                if (savedEntry) {
                                    entry.score = savedEntry.score;
                                    console.log(`‚úÖ Restored score for ${entry.userName}: ${entry.score}`);
                                }
                            }
                        });
                        
                        // Update display with restored scores
                        updateEntriesTable(currentEntries);
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Failed to restore saved scores:', error);
                    }
                }
            }
        };
    
    </script>
</body>
</html>